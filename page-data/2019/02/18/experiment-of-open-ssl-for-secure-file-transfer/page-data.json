{"componentChunkName":"component---src-templates-post-js","path":"/2019/02/18/experiment-of-open-ssl-for-secure-file-transfer/","result":{"data":{"wordpressPost":{"id":"e368f8e6-2868-56bf-aadc-137cb9e84ccd","title":"OpenSSLを使った安全なファイルの転送を検証してみる","excerpt":"<p>こんにちは！今年もあと残すところ11ヶ月を切ってしまいました。時間が経つのは早いですね・・・。さて、今回はOpenSSLを使って表題の件を検証をしてみたいと思います。 先日、とあるファイル共有サービスのログイン情報を含む [&hellip;]</p>\n","slug":"experiment-of-open-ssl-for-secure-file-transfer","content":"\n<p>こんにちは！今年もあと残すところ11ヶ月を切ってしまいました。時間が経つのは早いですね・・・。<br>さて、今回はOpenSSLを使って表題の件を検証をしてみたいと思います。</p>\n\n\n\n<p>先日、とあるファイル共有サービスのログイン情報を含む会員情報が流出すると言うインシデントがあったのは記憶に新しいかと思います。<br>これを書いている2月13日時点では、顧客のファイル自体の流出については報告がありませんが、利用者としては最悪の事態を想定する他ありません。</p>\n\n\n\n<p>その上で、利用者として、今後この様な事故の被害を最小限に抑えるにはどうしたら良いでしょうか？<br>色々あるかと思いますが、1つは暗号化です。<br>大抵の場合インターネット上でファイルを送受信する際には必ず使われている暗号化ですが、今回のケースのように、それを解く為のクレデンシャルが流出していた場合意味がありません。<sup><a id=\"to-annotate-1\" href=\"#annotate-1\">[1]</a></sup></p>\n\n\n\n<p>今回の事故以外でも、単に権限をミスったりしてファイルが流出していたなんて事もあります。これはGoogle Driveを使おうがAmazon S3を使おうが一緒です。<sup><a href=\"#annotate-2\" id=\"to-annotate-2\">[2]</a></sup></p>\n\n\n\n<p>ファイルを転送する前に自前で更に暗号化をし、更に受信者だけが確実に復号できる仕組みを用意できれば、少しは安心できそうな気がします。</p>\n\n\n\n<p>と言う訳で、長くなりましたが以上が本件を書こうと思った経緯です。</p>\n\n\n\n<p>また、今回検証には全てmacOS Mojaveを使っており、OpenSSLも最初から入っている物を使ってます。</p>\n\n\n\n<h2 id=\"対象読者\"><a href=\"https://hackmd.io/pqYt6WqgReuZX3Nlr0svCw?view#%E5%AF%BE%E8%B1%A1%E8%AA%AD%E8%80%85\"></a>対象読者</h2>\n\n\n\n<p>共通鍵暗号、公開鍵暗号等の暗号化技術にあまり詳しくない方。もしくは、OpenSSLを使って実際に暗号化を行った事が無い方を対象としています。</p>\n\n\n\n<h2 id=\"免責\"><a href=\"https://hackmd.io/pqYt6WqgReuZX3Nlr0svCw?view#%E5%85%8D%E8%B2%AC\"></a>免責</h2>\n\n\n\n<p>一応、今回プログラム等は試験的に実装した物なのでガチでセンシティブなファイルの転送には使わないで下さい。&nbsp;<sup><a href=\"#annotate-3\" id=\"to-annotate-3\">[3]</a></sup></p>\n\n\n\n<h2 id=\"共通鍵暗号と公開鍵暗号\"><a href=\"https://hackmd.io/pqYt6WqgReuZX3Nlr0svCw?view#%E5%85%B1%E9%80%9A%E9%8D%B5%E6%9A%97%E5%8F%B7%E3%81%A8%E5%85%AC%E9%96%8B%E9%8D%B5%E6%9A%97%E5%8F%B7\"></a>共通鍵暗号と公開鍵暗号</h2>\n\n\n\n<p>インターネット上でよく使う暗号化の方法としては主にこの2種類があると思います。それぞれの特徴を、OpenSSLでの実行例を添えて紹介します。</p>\n\n\n\n<p><strong>共通鍵暗号</strong></p>\n\n\n\n<p>暗号化時と復号時&nbsp;<sup><a id=\"to-annotate-4\" href=\"#annotate-4\">[4]</a></sup>&nbsp;に使う鍵が一緒のタイプです。パスワード付きZIPやWi-Fiでもおなじみの、一般的によく使われる暗号化方式かと思います。</p>\n\n\n\n<p>ちなみにここで言う鍵というのは復号の方法を表す情報と言う事になります。したがって、例えば以下のような物も共通鍵暗号と言えます。</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n暗号：ハテネオヌヅモカナキワソブソア\n平文：ヒトノカネデヤキニクヲタベタイ（人の金で焼き肉を食べたい）\n鍵：1文字ずつ50音の1つ前のカナに変換\n</pre>\n\n\n<p>特徴としては、（当たり前ですが）暗号化したデータと共に、暗号化に使った鍵もどうにかして転送する必要があります。<sup><a id=\"to-annotate-5\" href=\"#annotate-5\">[5]</a></sup></p>\n\n\n\n<p>以下は、OpenSSLでの使用例です。<br>まずは暗号化から。以下は “Secret Message!!” と言う平文のメッセージを、AES-256-CBC (共通鍵暗号の一種) を使ってパスワード (鍵) “hogehoge” で暗号化し、標準出力に結果を出力します:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ echo 'Secret Message!!' | openssl enc -aes-256-cbc -salt -k hogehoge -base64\n\nU2FsdGVkX1+mdCMdi+jRV7bwJaSm+LxUjnTax98O9ZWSa/s45UHmzagIF+Nt6nqp\n</pre>\n\n\n<p><code>-salt</code>&nbsp;をつけると実行する度に異なる結果が得られ安全です（デフォルトで有効）。また、出力結果を見やすくする為に今回はbase64化して出力しています。</p>\n\n\n\n<p>続いてこのメッセージを復号してみましょう。<br>逆の手順で今度はbase64デコードした後、AES-256-CBCで同じ鍵で復号を行います:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ echo 'U2FsdGVkX1+mdCMdi+jRV7bwJaSm+LxUjnTax98O9ZWSa/s45UHmzagIF+Nt6nqp' | openssl enc -d -aes-256-cbc -k hogehoge -base64\n\nSecret Message!!\n</pre>\n\n\n<p>無事メッセージを戻す事ができました！</p>\n\n\n\n<p><strong>公開鍵暗号</strong></p>\n\n\n\n<p>共通鍵暗号とは対象的に、暗号化と復号で異なる2つの鍵（鍵ペア）を使います。受信側が予め鍵ペアを作り、片方の鍵を “公開鍵” として送信側に渡します。送信者はそれを使い暗号化を行い、受信側に転送します。受信者はデータを受け取った後、所有するもう一方の鍵 “秘密鍵” を使って復号を行います。<br>公開鍵暗号では、公開鍵で暗号化したデータは、秘密鍵でしか復号できない為、公開鍵の転送は安全な手段を用いる必要はありません。この性質から、安全にデータの転送が可能となります。<sup><a id=\"to-annotate-6\" href=\"#annotate-6\">[6]</a></sup></p>\n\n\n\n<p>因みに有名な公開鍵暗号アルゴリズムのRSAでは、巨大な2つの素数を掛け合わした数値に対する、素因数分解の困難性を安全性の根拠としています。</p>\n\n\n\n<p>それでは、実際にOpenSSLを使ってそのRSAを使って暗号化＆復号を試してみましょう。</p>\n\n\n\n<p>まずは鍵ペアを生成します。以下は、2048bitのRSA秘密鍵 (公開不可の方) を作り、<code>private.pem</code>に保存します:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ openssl genrsa -out private.pem 2048\n\nGenerating RSA private key, 2048 bit long modulus\n..............................................................................................+++\n........+++\ne is 65537 (0x10001)\n</pre>\n\n\n<p>続いて、この秘密鍵から公開鍵を取り出します。秘密鍵には公開鍵の情報が入っている為、いつでも公開鍵の生成が可能です&nbsp;<sup><a id=\"to-annotate-7\" href=\"#annotate-7\">[7]</a></sup>:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ openssl rsa -in private.pem -outform PEM -pubout -out public.pem\n\nwriting RSA key\n</pre>\n\n\n<p>それではこの鍵ペアを使って実際に暗号化を行います。以下は、“Secret Message!!” と言うメッセージをRSAの公開鍵で暗号化し、base64に変換し結果を標準出力に出力します:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ echo 'Secret Message!!' | openssl rsautl -encrypt -inkey public.pem -pubin | base64\n\nqUkeauQ7dCdfZENyBICyhG5xSVwGDFfltoFU1jsJ21nGVPaOoKp6xk7b6mVzkf+zx6mypH7ARcWRO4Ki/DcSsRXZgUqv0jeEdLJTz2XPjf72hwL+sZCcQBkrHb/uY9ztYzOkeyIBZzZbl7QrQdyIPmJL248UR6sEQwtQz+U4c25yuQtmyno5a1+Ae2xBPJJZZy1xZlmOuW5KarGeCliRU5ya6GwEdWoRSuO4zLgsFYmPP/l0ItGBL/uo+dTFuNpbcdZiRZ3V52rnR2L8txf2EKv5gMkbB+kt46wtQp5CsnON8/VhuHBK8q1HwiAD29DxIMZSAqtCnHVZbpdmkbwc5A==\n</pre>\n\n\n<p><code>-pubin</code>&nbsp;は公開鍵を使う事を明示します。省略した場合、OpenSSLは秘密鍵が入力されている事を期待して暗号化を行う (実際には、先述の保持されている公開鍵が使われる) ので、エラーとなってしまうので注意が必要です。</p>\n\n\n\n<p>念の為、本当に公開鍵で復号できないか試してみましょう。以下は、先程のbase64メッセージをデコードして、公開鍵を使って復号を試みます:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ echo 'qUkeauQ7dCdfZENyBICyhG5xSVwGDFfltoFU1jsJ21nGVPaOoKp6xk7b6mVzkf+zx6mypH7ARcWRO4Ki/DcSsRXZgUqv0jeEdLJTz2XPjf72hwL+sZCcQBkrHb/uY9ztYzOkeyIBZzZbl7QrQdyIPmJL248UR6sEQwtQz+U4c25yuQtmyno5a1+Ae2xBPJJZZy1xZlmOuW5KarGeCliRU5ya6GwEdWoRSuO4zLgsFYmPP/l0ItGBL/uo+dTFuNpbcdZiRZ3V52rnR2L8txf2EKv5gMkbB+kt46wtQp5CsnON8/VhuHBK8q1HwiAD29DxIMZSAqtCnHVZbpdmkbwc5A==' | base64 --decode | \\\n  openssl rsautl -decrypt -inkey public.pem -pubin\n\nA private key is needed for this operation\n</pre>\n\n\n<p>無事（？）怒られました。では今度は指示に従って秘密鍵を使いましょう:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ echo 'qUkeauQ7dCdfZENyBICyhG5xSVwGDFfltoFU1jsJ21nGVPaOoKp6xk7b6mVzkf+zx6mypH7ARcWRO4Ki/DcSsRXZgUqv0jeEdLJTz2XPjf72hwL+sZCcQBkrHb/uY9ztYzOkeyIBZzZbl7QrQdyIPmJL248UR6sEQwtQz+U4c25yuQtmyno5a1+Ae2xBPJJZZy1xZlmOuW5KarGeCliRU5ya6GwEdWoRSuO4zLgsFYmPP/l0ItGBL/uo+dTFuNpbcdZiRZ3V52rnR2L8txf2EKv5gMkbB+kt46wtQp5CsnON8/VhuHBK8q1HwiAD29DxIMZSAqtCnHVZbpdmkbwc5A==' | base64 --decode | \\\n  openssl rsautl -decrypt -inkey private.pem\n\nSecret Message!!\n</pre>\n\n\n<p>無事に戻す事ができましたね♪</p>\n\n\n\n<h2 id=\"2つの手法を組み合わせる\"><a href=\"https://hackmd.io/pqYt6WqgReuZX3Nlr0svCw?view#2%E3%81%A4%E3%81%AE%E6%89%8B%E6%B3%95%E3%82%92%E7%B5%84%E3%81%BF%E5%90%88%E3%82%8F%E3%81%9B%E3%82%8B\"></a>2つの手法を組み合わせる</h2>\n\n\n\n<p>ここで勘の良い方なら、「公開鍵暗号最強やん！共通鍵暗号の存在意義って・・・」と思うかもしれません。が、公開鍵暗号だけを使うのは難しい理由があります。それは、RSAを使った公開鍵暗号では、もとのメッセージは鍵長以下である必要があると言う制約があるからです。<br>例えば先程の例のように2048bit (256バイト) の鍵長であれば、256バイトまでのデータしか暗号化できません。更に言えば、デフォルトにもなっている <code>PKCS #1 v1.5 padding</code> と言うパディングが入るため、 (<a rel=\"noreferrer noopener\" href=\"https://tools.ietf.org/html/rfc2313\" target=\"_blank\">RFC-2313</a>によると) 更に11バイト低い、245バイトまでが上限となります。</p>\n\n\n\n<p>この様な制限から、実際のデータの通信にはRSAは不向きと言えます。そこで、ファイル自体の暗号化にはサイズの制約の少ない共通鍵暗号を使い、その鍵自体を公開鍵暗号を使って暗号化する事で、安全に暗号データと、その復号の為のキーを受信者に送付する事が可能となります。<sup><a id=\"to-annotate-8\" href=\"#annotate-8\">[8]</a></sup></p>\n\n\n\n<h2 id=\"実際にやってみた\"><a href=\"https://hackmd.io/pqYt6WqgReuZX3Nlr0svCw?view#%E5%AE%9F%E9%9A%9B%E3%81%AB%E3%82%84%E3%81%A3%E3%81%A6%E3%81%BF%E3%81%9F\"></a>実際にやってみた</h2>\n\n\n\n<p>長くなりましたがいよいよ本題です。先程書いた通り、2つの暗号化方式を組み合わせますので、具体的なフローしては次のような形になります:</p>\n\n\n\n<ol><li><strong>受信者</strong>: 公開鍵暗号 (RSA) の鍵ペアを生成</li><li><strong>受信者</strong>: 1の「公開鍵」を送信者に送付</li><li><strong>送信者</strong>: 256bit (32バイト) 長のランダム値を生成。これを共通鍵暗号 (AES) の鍵とする</li><li><strong>送信者</strong>: 3で作った「共通鍵」で、送信したい機密データを暗号化する</li><li><strong>送信者</strong>: 3で作った「共通鍵」を、2で受け取った「公開鍵」で暗号化する</li><li><strong>送信者</strong>: 4と5を受信者に送付</li><li><strong>受信者</strong>: 6で受け取った「共通鍵」を、1で生成した「秘密鍵」で復号する</li><li><strong>受信者</strong>: 6で受け取った暗号データを、7で復号した「共通鍵」で復号する</li></ol>\n\n\n\n<p>自分が送信者の場合、事前に受信相手にRSA秘密鍵を生成してもらう必要がありますが、相手がGitHubのユーザーで、かつSSHの認証用にRSAの鍵を登録している場合、手間が省けます。<br>何故ならユーザーが登録している公開鍵は、誰でも参照が可能だからです。因みに僕の鍵の場合、以下となります:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ curl -s https://github.com/issei-m.keys\n\nssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQC8EfkPUlQE7/z8chnxgmmRX1efaPLO3AKLpXlasPSU/T4eQjahIwz2AC8jowGIXfiUZG2QLgSbMzRkzJC59FAXGzF+ty3VIMMxrA37h2NGuAstr7snzOODx3jph+tJjPZoMx07PGLN4JYysv8eZ/C7ULihdRLBsImQNOStEFNVVm7zNKF0LbvaVuAsbgtpd8L0OaeTWMWEok5K/QRNunnRb6p/q45EyHpN0gWFCByp3pXPu3/QVJTprr/Y1T93uhAZwL1EmB8vHbwAwbb9L/+TOUeY2IXxoykuhhZpXz+0HD9p6iNcv5ABDJNhKMEjjfNq2gKWhc7G2bQwiRT9ELjOvuChBq2ITqw/KaDklORqHK8fzsvPZIe6Rmf9zwNUJPAng360m81kLsWrTiaGA2iR8jKAk0sElPIvNpopFx/VX2rk/RMBptK0zHbZ3X1qFw5ReQ7NFbg3nHSO3po9C463PphDt8HBNoBunzqH40q+XXe7cDvvX4u8ShapJSFdcB1VHUiRm/HRkJaun4Iq2R00oZURcV49NEnB9z2l+0UtqKZHj78l7UBDMe/pa4vrrmbxiUZoB1msrnhrnXW+lytZAHEvTow4RTM5U/14mxbwhs6s4F8ljci4P/0YnH7WBvd9xR/f6M21LM6WWXGvCv+92xYd9DSBjb8z8G35J1Tm1w==\n</pre>\n\n\n<p>尚、この形式のままだとOpenSSLで使えませんので、使える形式に変換しておきます。これに関してはOpenSSHと言う、名前はそっくりですが別のライブラリの機能を使う必要があります。</p>\n\n\n\n<p>以下は、GitHubから取得した&nbsp;<code>issei-m</code>&nbsp;の鍵をOpenSSLで使えるPKCS8形式に変換し、<code>./issei-m.pem</code>&nbsp;に保存します:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ curl -s https://github.com/issei-m.keys &gt; /tmp/issei-m.key\n$ ssh-keygen -f /tmp/issei-m.key -e -m PKCS8 | tee -a issei-m.pem\n\n-----BEGIN RSA PUBLIC KEY-----\nMIICCgKCAgEAvBH5D1JUBO/8/HIZ8YJpkV9Xn2jyztwCi6V5WrD0lP0+HkI2oSMM\n9gAvI6MBiF34lGRtkC4EmzM0ZMyQufRQFxsxfrct1SDDMawN+4djRrgLLa+7J8zj\ng8d46YfrSYz2aDMdOzxizeCWMrL/Hmfwu1C4oXUSwbCJkDTkrRBTVVZu8zShdC27\n2lbgLG4LaXfC9Dmnk1jFhKJOSv0ETbp50W+qf6uORMh6TdIFhQgcqd6Vz7t/0FSU\n6a6/2NU/d7oQGcC9RJgfLx28AMG2/S//kzlHmNiF8aMpLoYWaV8/tBw/aeojXL+Q\nAQyTYSjBI43zatoCloXOxtm0MIkU/RC4zr7goQatiE6sPymg5JTkahyvH87Lz2SH\nukZn/c8DVCTwJ4N+tJvNZC7Fq04mhgNokfIygJNLBJTyLzaaKRcf1V9q5P0TAabS\ntMx22d19ahcOUXkOzRW4N5x0jt6aPQuOtz6YQ7fBwTaAbp86h+NKvl13u3A771+L\nvEoWqSUhXXAdVR1IkZvx0ZCWrp+CKtkdNKGVEXFePTRJwfc9pftFLaimR4+/Je1A\nQzHv6WuL665m8YlGaAdZrK54a511vpcrWQBxL06MOEUzOVP9eJsW8IbOrOBfJY3I\nuD/9GJx+1gb3fcUf3+jNtSzOlllxrwr/vdsWHfQ0gY2/M/Bt+SdU5tcCAwEAAQ==\n-----END RSA PUBLIC KEY-----\n</pre>\n\n\n<p>これで準備ができました。<br>さて、今回は先述のフローの3〜8までの手順を自動化するBashスクリプトを書きましたのでそちらを使います。</p>\n\n\n\n<p><a href=\"https://raw.githubusercontent.com/issei-m/openssl-command-tests/master/file-encrypter\" target=\"_blank\" rel=\"noreferrer noopener\">file-encrypter &#8211; github.com/issei-m/openssl-command-tests</a></p>\n\n\n\n<p>暗号化の場合は次のようにして実行します:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ ./file-encrypter enc RSA公開鍵ファイル名 暗号化したいファイル名\n</pre>\n\n\n<p>実際に、もばらぶのロゴを先程の僕の鍵で暗号化してみましょう。まずはロゴをDLします:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ curl -s -O http://mobalab.net/images/logo.png\n</pre>\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://i0.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/image.png?w=1200&#038;ssl=1\" alt=\"\" class=\"wp-image-584\" srcset=\"https://i0.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/image.png?w=570&amp;ssl=1 570w, https://i0.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/image.png?resize=300%2C146&amp;ssl=1 300w\" sizes=\"(max-width: 570px) 100vw, 570px\" data-recalc-dims=\"1\" /><figcaption>もばらぶロゴ</figcaption></figure></div>\n\n\n\n<p>一応md5も見てみましょう:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ md5 logo.png\nMD5 (logo.png) = 71869c2dad963c935638ba1f227428d6\n</pre>\n\n\n<p>続いて&nbsp;<code>file-encrypter</code>&nbsp;スクリプトで暗号化を行います。</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ ./file-encrypter enc ./issei-m.pem /path/to/logo.png             \nEncrypted into: ./logo.png.enc\n</pre>\n\n\n<p><code>./[元のファイル名].enc</code>&nbsp;と言う名前で出力されるので、今回は&nbsp;<code>./logo.png.enc</code>&nbsp;に出力されました。<br>この1ファイルの中に、暗号化したAESの鍵と暗号化した本文が含まれているので、後はこのファイルを相手に送付するだけです。</p>\n\n\n\n<p>それでは受け取り側を想定して復号を行います。復号も暗号の時とほぼ同じインターフェースです:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ ./file-encrypter dec RSA秘密鍵ファイル名 復号したいファイル名\n</pre>\n\n\n<p>暗号化に使ったGitHubに登録している僕の鍵の秘密鍵は、唯一僕のマシンの中にだけありますので、それを使って復号を行います:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n# 元のファイルがあると「すでに同名のファイルが有るよ」と怒られるので予め削除しておく事\n$ ./file-encrypter dec /path/to/issei-m-private.pem ./logo.png.enc \nDecrypted into: ./logo.png\n</pre>\n\n\n<p>無事に元のファイル名でファイルが作られました。MD5を取ってみましょう:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ md5 logo.png\nMD5 (logo.png) = 71869c2dad963c935638ba1f227428d6\n</pre>\n\n\n<p>先ほどと一緒ですね。と言う事で、復号は無事にできました！</p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter\"><img src=\"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/image-2.png?w=1200&#038;ssl=1\" alt=\"\" class=\"wp-image-586\" srcset=\"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/image-2.png?w=570&amp;ssl=1 570w, https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/image-2.png?resize=300%2C146&amp;ssl=1 300w\" sizes=\"(max-width: 570px) 100vw, 570px\" data-recalc-dims=\"1\" /><figcaption>無事復活を遂げたもばらぶロゴ</figcaption></figure></div>\n\n\n\n<h2 id=\"おわりに\"><a href=\"https://hackmd.io/pqYt6WqgReuZX3Nlr0svCw?view#%E3%81%8A%E3%82%8F%E3%82%8A%E3%81%AB\"></a>おわりに</h2>\n\n\n\n<p>今回、TLS等でも使われている様な、暗号化のフローの一部をOpenSSLを使って検証してみました。<br>今回はシェルスクリプトを使いましたが、OpenSSL用のライブラリがあれば当然他の言語でも実装が可能ですので、興味がある方は試してみて下さい。</p>\n\n\n\n<h2 id=\"参考\"><a href=\"https://hackmd.io/pqYt6WqgReuZX3Nlr0svCw?view#%E5%8F%82%E8%80%83\"></a>参考</h2>\n\n\n\n<ul><li class=\"\"><a href=\"https://en.wikipedia.org/wiki/RSA_(cryptosystem)\" target=\"_blank\" rel=\"noreferrer noopener\">https://en.wikipedia.org/wiki/RSA_(cryptosystem)</a></li><li class=\"\"><a href=\"https://en.wikipedia.org/wiki/Advanced_Encryption_Standard\" target=\"_blank\" rel=\"noreferrer noopener\">https://en.wikipedia.org/wiki/Advanced_Encryption_Standard</a></li><li class=\"\"><a href=\"https://www.openssl.org/docs/man1.0.2/man1/\" target=\"_blank\" rel=\"noreferrer noopener\">https://www.openssl.org/docs/man1.0.2/man1/</a></li><li class=\"\"><a href=\"https://www.devco.net/archives/2006/02/13/public_-_private_key_encryption_using_openssl.php\" target=\"_blank\" rel=\"noreferrer noopener\">https://www.devco.net/archives/2006/02/13/public_-_private_key_encryption_using_openssl.php</a></li><li class=\"\"><a href=\"https://man.openbsd.org/ssh-keygen.1\" target=\"_blank\" rel=\"noreferrer noopener\">https://man.openbsd.org/ssh-keygen.1</a></li></ul>\n\n\n\n<hr class=\"wp-block-separator\"/>\n\n\n\n<ol><li id=\"annotate-1\">インシデントに気づいて速攻でサービスを停止できればOKですが&nbsp;<a href=\"#to-annotate-1\">↩︎</a></li><li id=\"annotate-2\">実際にS3での事故はたまに<a rel=\"noreferrer noopener\" href=\"https://www.upguard.com/breaches/verizon-cloud-leak\" target=\"_blank\">見ます</a>&nbsp;<a href=\"#to-annotate-2\">↩︎</a></li><li id=\"annotate-3\">よく検証されてる＆使いやすいツールがインターネット上にはたくさんあるのでそちらを使って下さい&nbsp;<a href=\"#to-annotate-3\">↩︎</a></li><li id=\"annotate-4\">どうでもいいですが、暗号化の対語として「復号化」は<a rel=\"noreferrer noopener\" href=\"https://qiita.com/shojit/items/13ef9deebcae71a4f0cb\" target=\"_blank\">誤りらしい</a>です。個人的には通じればどちらでもOK派ですが&nbsp;<a href=\"#to-annotate-4\">↩︎</a>\n    </li><li id=\"annotate-5\">インターネット上では原則的に安全にファイルの送受信が困難な為に暗号処理を使いますが、共通鍵暗号の場合、結局その鍵自体にも同じ課題が課され、ジレンマになります&nbsp;<a href=\"#to-annotate-5\">↩︎</a>\n    </li><li id=\"annotate-6\">因みに公開鍵暗号は南京錠によく例えられます。解錠した南京錠を使って誰でもロックを掛ける事ができますが、解錠だけは鍵の所有者だけが可能だからです&nbsp;<a href=\"#to-annotate-6\">↩︎</a></li><li id=\"annotate-7\">当たり前ですが逆 (公開鍵から秘密鍵を取り出す) は不可能です&nbsp;<a href=\"#to-annotate-7\">↩︎</a></li><li id=\"annotate-8\">普段私達がWebで使っているTLSでも同様のフローが使われています&nbsp;<a href=\"#to-annotate-8\">↩︎</a></li></ol>\n","dateObject":"2019-02-18T00:00:54.000Z","date":"February 18, 2019","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"AES","slug":"aes"},{"name":"Cryptography","slug":"cryptography"},{"name":"OpenSSL","slug":"openssl"},{"name":"RSA","slug":"rsa"},{"name":"Security","slug":"security"}],"author":{"name":"issei_m","slug":"issei"},"featured_media":{"media_details":{"sizes":{"large":{"source_url":"https://i1.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/marcos-mayer-735961-unsplash-scaled.jpg?fit=1024%2C683&ssl=1","height":683,"width":1024},"medium_large":{"source_url":"https://i1.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/marcos-mayer-735961-unsplash-scaled.jpg?fit=768%2C512&ssl=1","height":512,"width":768}}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/marcos-mayer-735961-unsplash-scaled.jpg"},"wordpress_id":583}},"pageContext":{"id":"e368f8e6-2868-56bf-aadc-137cb9e84ccd","nextPath":"/2019/02/17/react-native-cameraで画像を正方形で保存する方法/","nextTitle":"React Native Cameraで画像を正方形で保存する方法","prevPath":"/2019/02/25/use-multiple-aws-accounts-in-serverless/","prevTitle":"Serverless で複数の AWS アカウントを使用する"}}}