{"componentChunkName":"component---src-templates-post-js","path":"/2019/02/17/react-native-cameraで画像を正方形で保存する方法/","result":{"data":{"wordpressPost":{"id":"fd1f67ef-8aa9-5b4f-be8d-a5548fd2fce8","title":"React Native Cameraで画像を正方形で保存する方法","excerpt":"<p>はじめに 皆さんこんにちは。React Nativeのカメラ機能を使用するうえで、react-native-cameraというおそらく一番メジャーなカメラ機能のパッケージ（外部モジュール）を使用したのですが、静止画像の大 [&hellip;]</p>\n","slug":"react-native-camera%e3%81%a7%e7%94%bb%e5%83%8f%e3%82%92%e6%ad%a3%e6%96%b9%e5%bd%a2%e3%81%a7%e4%bf%9d%e5%ad%98%e3%81%99%e3%82%8b%e6%96%b9%e6%b3%95","content":"\n<h2><strong>はじめに</strong></h2>\n\n\n\n<p>皆さんこんにちは。React Nativeのカメラ機能を使用するうえで、react-native-cameraというおそらく一番メジャーなカメラ機能のパッケージ（外部モジュール）を使用したのですが、静止画像の大きさを通常の縦長の形ではなくて正方形などの形で保存するということが、iOSでは簡単にできたのですが恐らくパッケージ自体のバグによりAndroidではうまくできませんでした。</p>\n\n\n\n<p>最終的に上下の余白をカットして正方形にクロップする処理を行うことで、正方形などの縦長以外の形で画像を保存することができました。（パッケージ自体が修正されるのが一番いいのですが、現時点では私が調べた限りではアプリ側での対応策としては画像をクロップするという方法しかみつかりませんでした・・。）オーバーレイの調整などいろいろと大変だったので最終的にうまく行った方法を<a href=\"#sample-code\">サンプルコード</a>とともに紹介します。</p>\n\n\n\n<p>この記事でのReact nativeとreact native cameraのバージョンはそれぞれ以下のものを使用しています。 </p>\n\n\n\n<pre class=\"wp-block-code\"><code>\"react-native\": \"0.57.8\"\n\"react-native-camera\": \"1.8.0\"</code></pre>\n\n\n\n<h2><strong>Androidで画像が正方形に保存されず、かつ横向きになってしまう問題</strong></h2>\n\n\n\n<p>React Native Cameraを使用する上で、iOSではプレビュー画面のViewのスタイルを単純に変更して正方形にすることで自動的にプレビュー画面と同じ画面の比率で画像を保存することができました。しかし、Androidでは（バージョンや機種によって多少挙動が異なる部分はあったのですが）プレビュー画面そのものを正方形に表示させることができなかったり、プレビュー画面を正方形に表示させることはできても、保存される画像自体は縦長のままで保存されてしまうという現象に悩まされました。</p>\n\n\n\n<p>また、Androidでは画像が保存される際に90度回転された方向で保存されてしまい、保存した画像をサーバー側やアプリ内で表示させる際に保存された通りの90度回転された横向きの状態で表示されてしまうという問題も発生しましたので、こちらの対策として画像を回転させて保存するという処理も併せて行う必要がありました。 </p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/ios_android-1.png?w=1200&#038;ssl=1\" alt=\"\" class=\"wp-image-618\" srcset=\"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/ios_android-1.png?w=927&amp;ssl=1 927w, https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/ios_android-1.png?resize=300%2C166&amp;ssl=1 300w, https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/ios_android-1.png?resize=768%2C425&amp;ssl=1 768w\" sizes=\"(max-width: 927px) 100vw, 927px\" data-recalc-dims=\"1\" /></figure>\n\n\n\n<p>（ちなみに本記事とは関係はないのですが、iOSでは正しい方向で画像は保存されるのですが、画像に付与されるexif情報では「-90度に回転」という情報がiOSのみ含まれていました。アプリ内では問題なかったのですがサーバーで表示させる際に90度回転した状態で表示されてしまい、React Nativeでexif情報を削除する方法がわからなかったのでこちらに関しては画像サーバーにアップロードする段階で画像の方向を修正するという処理を行いました・・。） </p>\n\n\n\n<h2><strong>オーバーレイでプレビュー画面を正方形に表示</strong></h2>\n\n\n\n<p> iOSでは必要がないのですが、Androidではreact-native-cameraモジュールのプレビュー画面の大きさを調整できなかったので、オーバーレイを表示させることでプレビュー画面の上下部分を隠すことでプレビュー画面を正方形のように表示させました。（react-native-cameraのバージョンは1.8.0を使用していますが、バージョンによってはこの処理は必要なくプレビュー画面をViewのスタイルを変更することで大きさが変えられることもあるようですが、その場合でも保存される画像自体は縦向きになっていて、加工が必要なようです。） </p>\n\n\n\n<p>ここで正方形に加工する画像と、プレビュー画像を厳密に合わせるために以下のような形で上下に表示させるオーバーレイの高さを計算しました。注意点は、iOSとは異なり、Androidでは上部に表示させるステータスバーの高さの分を計算に入れる必要があるという点です。iOSではプレビュー画面のスタイルを変えることができるのでオーバーレイ自体を表示させる必要がそもそもないのですが、ここではオーバーレイの高さをiOS/Androidで調整することで正方形に加工する画像と、プレビュー画像を合わせるようにしています。 </p>\n\n\n\n<figure class=\"wp-block-image\"><img src=\"https://i2.wp.com/engineering.mobalab.net/wp-content/uploads/2019/02/overlay-1.png?fit=680%2C509&amp;ssl=1\" alt=\"\" class=\"wp-image-612\" srcset=\"https://i1.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/overlay-1.png?w=1596&amp;ssl=1 1596w, https://i1.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/overlay-1.png?resize=300%2C224&amp;ssl=1 300w, https://i1.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/overlay-1.png?resize=768%2C575&amp;ssl=1 768w, https://i1.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/overlay-1.png?resize=1024%2C766&amp;ssl=1 1024w\" sizes=\"(max-width: 1200px) 100vw, 1200px\" /></figure>\n\n\n\n<p>ここでの計算でステータスバーの高さを取得するために、以下のようにStatusBarモジュールをインポートする必要があります。 </p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { StatusBar } from 'react-native'; </code></pre>\n\n\n\n<p>表示するオーバーレイの高さoverlayHeightは正方形の場合は以下のようにして計算しています。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>const { width: windowWidth, height: windowHeight } = Dimensions.get('window');\nconst navHeight = Platform.OS === 'android' ? StatusBar.currentHeight : 0;\nconst overlayHeight = (windowHeight - navHeight - windowWidth) / 2;</code></pre>\n\n\n\n<figure class=\"wp-block-image is-resized\"><img src=\"https://i1.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/android_preview.png?resize=289%2C516&#038;ssl=1\" alt=\"\" class=\"wp-image-621\" width=\"289\" height=\"516\" srcset=\"https://i1.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/android_preview.png?w=342&amp;ssl=1 342w, https://i1.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/android_preview.png?resize=168%2C300&amp;ssl=1 168w\" sizes=\"(max-width: 289px) 100vw, 289px\" data-recalc-dims=\"1\" /><figcaption>オーバーレイをかぶせることで<br>プレビューが正方形になりました</figcaption></figure>\n\n\n\n<h2><strong>画像を90度回転させる</strong></h2>\n\n\n\n<p> 正方形の画像の上下の余白をカットする前に、横向きで保存されてしまっている画像を90度回転させる必要があったのですが、これを実現するためにreact-native-image-rotateというパッケージを使用しました。 <a href=\"https://github.com/dgladkov/react-native-image-rotate\">https://github.com/dgladkov/react-native-image-rotate</a></p>\n\n\n\n<p>パッケージのインストール </p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ npm install react-native-image-rotate</code></pre>\n\n\n\n<p>ネイティブのライブラリとリンクさせる</p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ react-native link react-native-image-rotate</code></pre>\n\n\n\n<p>下に上げたコードでは、右方向に90度画像を回転させて、rotatedUriというURIに画像が回転済みの保存されます。cache直下にReactNative_rotated_image_1090087420378345175.jpgのような形のファイル名で保存されることになります。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>const imagePath = '/image_path.jpg'; // 元の画像のパス\n\nImageRotate.rotateImage(\n  imagePath,\n  90,\n  (rotatedUri) => {\n    // 回転が成功したときの処理。\n    // rotatedUriが回転された画像のURIでcache直下に\n    // ReactNative_rotated_image_1090087420378345175.jpgのような形で回転済みの画像が保存される。\n  },\n  (error) => {\n    // エラーのときの処理\n  },\n);</code></pre>\n\n\n\n<p><a href=\"#sample-code\">サンプルコード</a>では、rotateImage()というメソッドで画像の回転を行っていますが、回転→クロップというような順番で非同期で処理を行う必要があるので、Promiseを使っています。また、回転の方向は常に同じ（常に-90度回転された状態で保存）で、かつ機種によっては正しい方向で保存される場合もあったので、「画像の横の長さ&gt;画像の縦の長さ」の場合のみ回転の処理を行っています。</p>\n\n\n\n<h2><strong>画像の上下の余白を切り取る</strong></h2>\n\n\n\n<p> 次に回転の処理を行ったあとに縦長で保存された画像の上下の余白を切り取る（クロップする）処理を行います。 </p>\n\n\n\n<p>こちらは外部のパッケージなどを利用する必要はなく、ImageEditorというReact Native自体に含まれるモジュールを使用して該当の処理を行って正方形、または横向きなどの形に画像を加工することができます。 </p>\n\n\n\n<pre class=\"wp-block-code\"><code>import { ImageEditor } from 'react-native'; </code></pre>\n\n\n\n<p>im画像の上下の余白を切り取るメソッド ここでは画像にクロップ処理を行うことで1:1の比率の正方形に加工していますが、クロップする画像の高さとオフセットを調整することで任意の比率の画像に加工することができます。 </p>\n\n\n\n<p>例えば下のコードでは、クロップを開始するオフセットの位置( x: 0, y: 100 )から幅500, 高さ300の大きさで画像を切り出すことができます。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>const imagePath = '/image_path.jpg'; // 元の画像のパス\n\nconst cropData = {\n  offset: { x: 0, y: 100 },\n  size: { width: 500, height: 300 },\n};\nImageEditor.cropImage(\n  imagePath,\n  cropData,\n  (croppedUri) => {\n    // クロップが成功したときの処理。\n    // croppedUriがクロップされた画像のURIでcache直下に\n    // ReactNative_cropped_image_89995556232220742.jpgのような形でクロップ済みの画像が保存される。\n  },\n  (error) => {\n    // エラーケース\n  },\n);</code></pre>\n\n\n\n<p><a href=\"#sample-code\">サンプルコード</a>ではcropImage()というメソッドで上下の余白を切り取る処理を行っています。サンプルでは画像にクロップ処理を行うことで1:1の比率の正方形に加工していますが、クロップする画像の高さとオフセットを調整することで任意の比率の画像に加工することができます。</p>\n\n\n\n<h2><strong>まとめ</strong></h2>\n\n\n\n<p> react-native-cameraを使う場合にiOSでは簡単にできる正方形での画像保存のために、Androidではこのようにいろいろと面倒な処理をする必要がありました。いずれはパッケージ自体が修正されるとは思いますが、それまでの間で正方形などの形で保存する場合がある時は、是非参考にしてみてください。（もしもっといい方法があるよー、という場合はコメント欄等で教えていただけると幸いです！）</p>\n\n\n\n<h2 id=\"sample-code\">サンプルコード</h2>\n\n\n\n<pre class=\"wp-block-code\"><code>import React, { Component } from 'react';\nimport {\n  Platform,\n  StyleSheet,\n  View,\n  TouchableOpacity,\n  Dimensions,\n  StatusBar,\n  ImageEditor,\n} from 'react-native';\nimport { RNCamera } from 'react-native-camera';\nimport ImageRotate from 'react-native-image-rotate';\n\nexport default class CameraTest extends Component {\n  constructor(props) {\n    super(props);\n    // 本サンプルでは簡略化のために画像に関するこれらの変数を処理のたびに上書きしています。\n    this.imagePath = '';\n    this.imageWidth = 0;\n    this.imageHeight = 0;\n  }\n\n  async takePicture() {\n    if (this.camera) {\n      const { uri, width, height } = await this.camera.takePictureAsync();\n      [this.imagePath, this.imageWidth, this.imageHeight] = [uri, width, height];\n      if (Platform.OS === 'android') {\n        try {\n          // 非同期処理で回転・クロップと順番に処理を行う\n          await this.rotateImage();\n          await this.cropImage();\n          // 成功ケース\n          console.log('成功', this.imagePath);\n        } catch (error) {\n          // エラーケース\n          console.log('エラー', error);\n        }\n      }\n    }\n  }\n\n  // 横向きに保存されてしまっている場合のみ、画像を90度回転させて縦長に保存する\n  rotateImage() {\n    return new Promise((resolve, reject) => {\n      if (this.imageWidth > this.imageHeight) {\n        ImageRotate.rotateImage(\n          this.imagePath,\n          90,\n          (rotatedUri) => {\n            this.imagePath = rotatedUri;\n            [this.imageWidth, this.imageHeight] = [this.imageHeight, this.imageWidth];\n            // cache直下にReactNative_rotated_image_1090087420378345175.jpgのような形で回転済みの画像が保存される。\n            console.log('回転完了', this.imagePath);\n            resolve();\n          },\n          (error) => {\n            reject(error);\n          },\n        );\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  // 縦長に保存された画像の上下の余分な部分を切り取って正方形に加工する\n  cropImage() {\n    return new Promise((resolve, reject) => {\n      if (this.imageWidth &lt; this.imageHeight) {\n        const croppedHeight = this.imageWidth; // ここでクロップする高さを指定。1:1に切り出したいので高さが幅になるように指定\n        const offsetY = (this.imageHeight - croppedHeight) / 2;\n        const cropData = {\n          offset: { x: 0, y: offsetY },\n          size: { width: this.imageWidth, height: croppedHeight },\n        };\n        ImageEditor.cropImage(\n          this.imagePath,\n          cropData,\n          (croppedUri) => {\n            this.imagePath = croppedUri;\n            this.imageHeight = croppedHeight;\n            // cache直下にReactNative_cropped_image_89995556232220742.jpgのような形でクロップ済みの画像が保存される。\n            console.log('クロップ完了', this.imagePath);\n            resolve();\n          },\n          (error) => {\n            reject(error);\n          },\n        );\n      } else {\n        resolve();\n      }\n    });\n  }\n\n  render() {\n    // Androidの場合のみ、ナビゲーションバーの高さを計算に入れる必要がある\n    const { width: windowWidth, height: windowHeight } = Dimensions.get('window');\n    const navHeight = Platform.OS === 'android' ? StatusBar.currentHeight : 0;\n    const overlayHeight = (windowHeight - navHeight - windowWidth) / 2;\n    return (\n      &lt;View style={styles.container}>\n        &lt;View style={[styles.overlayTop, { height: overlayHeight }]} />\n        &lt;RNCamera\n          ref={(ref) => {\n            this.camera = ref;\n          }}\n          style={styles.preview}\n        />\n        &lt;View style={[styles.overlayBottom, { height: overlayHeight }]}>\n          &lt;TouchableOpacity\n            onPress={this.takePicture.bind(this)}\n            style={styles.captureButton}\n          />\n        &lt;/View>\n      &lt;/View>\n    );\n  }\n}\n\nconst styles = StyleSheet.create({\n  container: {\n    zIndex: 0,\n    flex: 1,\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  overlayTop: {\n    zIndex: 1,\n    position: 'absolute',\n    top: 0,\n    width: '100%',\n    backgroundColor: '#dbdbdb',\n  },\n  overlayBottom: {\n    zIndex: 1,\n    position: 'absolute',\n    bottom: 0,\n    width: '100%',\n    backgroundColor: '#dbdbdb',\n    justifyContent: 'center',\n    alignItems: 'center',\n  },\n  preview: {\n    zIndex: 0,\n    width: '100%',\n    aspectRatio: 1, // Androidではここでのプレビュー画面の比率の指定が効かない...\n  },\n  captureButton: {\n    height: 50,\n    width: 50,\n    borderWidth: 3,\n    borderRadius: 25,\n    borderColor: 'white',\n  },\n});</code></pre>\n\n\n\n<p></p>\n","dateObject":"2019-02-17T14:45:36.000Z","date":"February 17, 2019","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"React Native","slug":"react-native"}],"author":{"name":"Konno","slug":"konno"},"featured_media":{"media_details":{"sizes":{"large":{"source_url":"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/photography-336685_1280.jpg?fit=1024%2C682&ssl=1","height":682,"width":1024},"medium_large":{"source_url":"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/photography-336685_1280.jpg?fit=768%2C512&ssl=1","height":512,"width":768}}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2019/02/photography-336685_1280.jpg"},"wordpress_id":607}},"pageContext":{"id":"fd1f67ef-8aa9-5b4f-be8d-a5548fd2fce8","nextPath":"/2019/02/06/mod-wsgi-and-loading-libraries/","nextTitle":"mod_wsgi とライブラリ読み込み","prevPath":"/2019/02/18/experiment-of-open-ssl-for-secure-file-transfer/","prevTitle":"OpenSSLを使った安全なファイルの転送を検証してみる"}}}