{"componentChunkName":"component---src-templates-post-js","path":"/2019/06/21/laravelの多対多のリレーションについて/","result":{"data":{"wordpressPost":{"id":"0aab5578-2db2-508c-9a1b-6e859184b14e","title":"Laravelの多対多のリレーションについて","excerpt":"<p>はじめに 皆さんこんにちは。Laravelの多対多のリレーションについて、曖昧な部分が多かったので勉強がてら基本的な部分を整理してみました。 多対多には中間テーブルとbelongsToMany()を使う 例えば「ブログ記 [&hellip;]</p>\n","slug":"laravel%e3%81%ae%e5%a4%9a%e5%af%be%e5%a4%9a%e3%81%ae%e3%83%aa%e3%83%ac%e3%83%bc%e3%82%b7%e3%83%a7%e3%83%b3%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6","content":"\n<h2>はじめに</h2>\n\n\n\n<p> 皆さんこんにちは。Laravelの多対多のリレーションについて、曖昧な部分が多かったので勉強がてら基本的な部分を整理してみました。</p>\n\n\n\n<h2>多対多には中間テーブルとbelongsToMany()を使う</h2>\n\n\n\n<p>例えば「ブログ記事」とそれに対する「タグ」の場合のように、それぞれのブログ記事は複数のタグを持ち、それぞれのタグも同様に複数のブログを持ち得るような場合で、中間テーブルが必要になるケースです。Laravelにおけるこのような多対多の関係は、belongsToMany()を使って定義されることになります。 </p>\n\n\n\n<p>belongsToMany()を使って定義した多対多のリレーションの場合、attach()/detach()/sync()などのメソッドを利用することができます。サンプルを使ってコンソールでそれらのメソッドを確認する方法も記載しましたので、参考にしてみてください。</p>\n\n\n\n<p>ちなみにhasManyThrough()を使っても例えばブログ記事から紐づくタグを取得するというようなことは可能なようですが、hasManyThrough()は３つのテーブルが介するケースに対するショートカットのようなものに過ぎないようなので、多対多のケースに関してはbelongsToMany()を使うことが適切なようです。（参考までにですが、<a href=\"#hasmanythrough\">こちら</a>にサンプルコードがあります）</p>\n\n\n\n<h2> belongsToMany()の使い方のサンプル</h2>\n\n\n\n<p>ここではArticle（ブログ記事）とTag（タグ）という２つのモデルについて、hasManyThrough()を使って多対多の関係を定義してコンソールで確認できるようになるまでのサンプルをまとめました。</p>\n\n\n\n<p>このようなケースではarticlesとtagsとarticle_tagの３つのテーブルが必要になります。中間テーブルに関してですが、関連するモデル名をアルファベット順で並べたarticle_tagという名前になり、article_idとtag_idというカラムが必要になります。（独自のテーブル名を用いることも可能ですが、その場合はhasManyThrough()の定義の際にテーブル名などの記述も必要になります。）</p>\n\n\n\n<h3>マイグレーションファイルと各モデルの作成</h3>\n\n\n\n<p>まずはブArticle（ブログ記事）とTag（タグ）という２つのモデルを作成し、同時にマイグレーションファイルも作成（-mオプションを使う）します。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ php artisan make:model Article -m\n$ php artisan make:model Tag -m</code></pre>\n\n\n\n<p>次に中間テーブルのマイグレーションファイルを作成します。中間テーブルに関しては独自のメソッド等必要なければモデルの定義は不要です。先述したように、テーブル名は関連するモデル名をアルファベット順で並べたarticle_tagという名前になり、article_idとtag_idというカラムが必要になります。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ php artisan make:migration create_article_tag_table --create=article_tag</code></pre>\n\n\n\n<p>Articleのマイグレーションファイルにはbody（本文）というカラムを追加しておきます。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public function up()\n    {\n        Schema::create('articles', function (Blueprint $table) {\n            $table->increments('id');\n            $table->string('body');\n            $table->timestamps();\n        });\n    }</code></pre>\n\n\n\n<p>Tagのマイグレーションファイルにはname（タグの名前）というカラムを追加しておきます。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public function up()\n    {\n        Schema::create('tags', function (Blueprint $table) {\n            $table->increments('id');\n            $table->string('name');\n            $table->timestamps();\n        });\n    }</code></pre>\n\n\n\n<p> 中間テーブルのマイグレーションファイルにはArticleとTagの外部キーをそれぞれ追加する必要があります。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public function up()\n    {\n        Schema::create('article_tag', function (Blueprint $table) {\n            $table->increments('id');\n            $table->integer('article_id');\n            $table->integer('tag_id');\n            $table->timestamps();\n        });\n    }</code></pre>\n\n\n\n<p> テーブルの定義が終わったので、マイグレーションを実行します。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ php artisan migrate</code></pre>\n\n\n\n<h3>\n\n多対多のリレーションを各モデルに定義する</h3>\n\n\n\n<p>最後にArticleとTagのモデルにそれぞれbelongsToMany()を使って多対多の定義を追加します。</p>\n\n\n\n<p>App\\Article.php</p>\n\n\n\n<pre class=\"wp-block-code\"><code>class Article extends Model\n{\n    /**\n     * Articleに紐付いたTagのリスト\n     */\n    public function tags()\n    {\n        return $this->belongsToMany('App\\Tag');\n    }\n}</code></pre>\n\n\n\n<p>App\\Tag.php</p>\n\n\n\n<pre class=\"wp-block-code\"><code>class Tag extends Model\n{\n    /**\n     * Tagに紐付いたArticleのリスト\n     */\n    public function articles()\n    {\n        return $this->belongsToMany('App\\Article');\n    }\n}</code></pre>\n\n\n\n<h2>多対多のリレーションをコンソールで確認してみる</h2>\n\n\n\n<p>最後にコンソール（tinker）からリレーションが正しく定義されているかどうかを確認してみます。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>$ php artisan tinker</code></pre>\n\n\n\n<p>ArticleとTagのテストデータをまずは投入しておきます。ここではArticleを一つとTagを３つ投入しました。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> App\\Article::insert([\"body\" => \"foo\"])\n>>> App\\Tag::insert([[\"name\" => \"B\"], [\"name\" => \"B\"], [\"name\" => \"C\"]])</code></pre>\n\n\n\n<h3>リレーションの紐づけ・解除</h3>\n\n\n\n<h4>新たに紐づけするにはattach()を使う</h4>\n\n\n\n<p>belongsToMany()で定義したtags()から、attach()というメソッドを使って紐づけ対象のidを引数にしてリレーションを紐付けることができます。 中間テーブルにレコードが自動的に挿入されます。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> $a = App\\Article::first() // Articleを取得\n>>> $a->tags()->attach(1) // id=1のTagを紐付ける</code></pre>\n\n\n\n<p>以下のように、attach() で紐づけられたTagを取得することができました。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> $a = App\\Article::first() // データベース上は紐づけされてもインスタンスは更新されないようなので改めて更新されたArticleを取得する\n>>> $a->tags // 紐付いたタグを取得する\n=> Illuminate\\Database\\Eloquent\\Collection {#2950\n     all: [\n       App\\Tag {#2932\n         id: 1,\n         name: \"A\",\n         created_at: null,\n         updated_at: null,\n         pivot: Illuminate\\Database\\Eloquent\\Relations\\Pivot {#2942\n           article_id: 1,\n           tag_id: 1,\n         },\n       },\n     ],\n   }</code></pre>\n\n\n\n<h4>紐づけを解除するにはdetach()を使う</h4>\n\n\n\n<p> detach()というメソッドはattach()の逆で、ヒモ付の解除をすることができます。中間テーブルのレコードが自動的に削除されます。各モデルのレコードには影響がありません。 </p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> $a->tags()->detach(1) // id=1のTagの紐付けを解除する</code></pre>\n\n\n\n<p>以下のように、detach()したことで紐付けられたTagが削除されたことが確認できました。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> $a = App\\Article::first() // 更新されたArticleを取得する\n>>> $a->tags\n=> Illuminate\\Database\\Eloquent\\Collection {#2958\n     all: [],\n   }</code></pre>\n\n\n\n<h4>まとめての紐づけと紐づけの解除を行うsync()</h4>\n\n\n\n<p>他にもsync()という便利なメソッドがあります。紐づけるidのリストを引数として渡すことで、まとめて紐づけを行い、かつリストにないidは全て自動的に削除することができます。</p>\n\n\n\n<p>こちらも同様に中間テーブルのレコードの追加・削除が自動的に行われ、各モデルのレコードには影響がありません。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> $a->tags()->sync([2, 3]) // id=1とid=2のTagを紐づけ、これ以外のものは紐づけを解除する</code></pre>\n\n\n\n<p>以下のように、まとめて紐づけされたTagを取得することができました。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> $a = App\\Article::first() // 更新されたArticleを取得する\n>>> $a->tags\n=> Illuminate\\Database\\Eloquent\\Collection {#2962\n     all: [\n       App\\Tag {#2957\n         id: 2,\n         name: \"B\",\n         created_at: null,\n         updated_at: null,\n         pivot: Illuminate\\Database\\Eloquent\\Relations\\Pivot {#2956\n           article_id: 1,\n           tag_id: 2,\n         },\n       },\n       App\\Tag {#2966\n         id: 3,\n         name: \"C\",\n         created_at: null,\n         updated_at: null,\n         pivot: Illuminate\\Database\\Eloquent\\Relations\\Pivot {#2963\n           article_id: 1,\n           tag_id: 3,\n         },\n       },\n     ],\n   }</code></pre>\n\n\n\n<h2 id=\"hasmanythrough\">おまけ：hasManyThrough()を使って紐付いたタグを取得する</h2>\n\n\n\n<p>本来は多対多の関係に関しては上に書いてきたようにbelongsToMany()を使って定義するべきなのですが、紐付いたタグの取得という部分に関しては、3つの関連するテーブルのリレーションということでhasManyThroughでも取得は可能なようでした。しかし、hasManyThroughは取得の際のショートカットのようなものに過ぎないようなのでこの場合は当然attach/detach/syncなどのメソッドは使うことはできません。多対多のリレーションに関しては常にbelongsToMany()で定義するべきなようです。</p>\n\n\n\n<p>あくまで参考ですが、上のサンプルに以下のような修正を行うことでhasManyThrough()でもArticleに紐づくTagを取得することができます。</p>\n\n\n\n<p>中間テーブルのモデルArticleTagのモデルを定義するファイルを作成し、テーブル名を定義します。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>&lt;?php\n\nnamespace App;\n\nuse Illuminate\\Database\\Eloquent\\Model;\n\nclass ArticleTag extends Model\n{\n    protected $table = 'article_tag'; // テーブル名を定義する。\n}</code></pre>\n\n\n\n<p>ArticleのTagとのリレーションをhasManyThrough()で定義するように修正します。ドキュメントにあるような形のリレーションとは異なるのでローカルキーや外部キーの指定の仕方が若干トリッキーです・・。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>    public function tags() {\n        return $this->hasManyThrough(\n            'App\\Tag',\n            'App\\ArticleTag',\n            'article_id',\n            'id',\n            'id',\n            'tag_id'\n        );\n    }</code></pre>\n\n\n\n<pre class=\"wp-block-code\"><code>>>> $a = App\\Article::first() // Articleを取得する\n>>> $a->tags\n=> ... 紐付けられたタグが取得できる。</code></pre>\n\n\n\n<p>このように、hasManyThrough()で定義したリレーションを使って紐付けられたタグを取得することが可能です。しかし、紐づけや紐づけの削除を行うには手動で中間テーブルのレコードをの追加・削除を行う必要があるので、多対多の関係にはドキュメント通りにbelongsToMany()を使いましょう！</p>\n","dateObject":"2019-06-21T09:00:26.000Z","date":"June 21, 2019","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"laravel","slug":"laravel"}],"author":{"name":"Konno","slug":"konno"},"featured_media":{"media_details":{"sizes":{"large":{"source_url":"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/06/blank-card-cardboard-1.jpg?fit=1024%2C683&ssl=1","height":683,"width":1024},"medium_large":{"source_url":"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/06/blank-card-cardboard-1.jpg?fit=768%2C512&ssl=1","height":512,"width":768}}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2019/06/blank-card-cardboard-1.jpg"},"wordpress_id":967}},"pageContext":{"id":"0aab5578-2db2-508c-9a1b-6e859184b14e","nextPath":"/2019/06/17/trying-elasticsearch-apache-hadoop-integration/","nextTitle":"Elasticsearch for Apache Hadoopを使ってSparkからAmazon ESにデータと連携してみた","prevPath":"/2019/06/25/tips-on-s3-and-cloudfront/","prevTitle":"S3とCloudFront関連のあれこれ"}}}