{"componentChunkName":"component---src-templates-post-js","path":"/2019/11/01/things-what-happen-to-list-wrapped-option-flatten/","result":{"data":{"wordpressPost":{"id":"9563bb53-db10-5e3c-97af-4bfc61ed02e6","title":"(Scala) List[Option[A]]#flattenで起きる事","excerpt":"<p>先日、kojiがOption（scala）の実用的な使い方 − データのマージ処理と言うナイスな記事を書いてくれたので、ScalaのOptionを包括した&nbsp;List#flatten&nbsp;についてもう少し掘 [&hellip;]</p>\n","slug":"things-what-happen-to-list-wrapped-option-flatten","content":"\n<p>先日、kojiが<a href=\"https://stg-engineering-wp.mobalab.net/2019/10/24/option%ef%bc%88scala%ef%bc%89%e3%81%ae%e5%ae%9f%e7%94%a8%e7%9a%84%e3%81%aa%e4%bd%bf%e3%81%84%e6%96%b9-%e2%88%92-%e3%83%87%e3%83%bc%e3%82%bf%e3%81%ae%e3%83%9e%e3%83%bc%e3%82%b8%e5%87%a6%e7%90%86/\" target=\"_blank\" rel=\"noreferrer noopener\">Option（scala）の実用的な使い方 − データのマージ処理</a>と言うナイスな記事を書いてくれたので、ScalaのOptionを包括した&nbsp;<code>List#flatten</code>&nbsp;についてもう少し掘り下げて見たいと思い、今回筆（キーボード）を取りました。</p>\n\n\n\n<p>かなり基本的な内容なのでScala初心者向けの記事となっています。</p>\n\n\n\n<p>まず以下に、kojiが書いたflattenの記述例を記載します:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nval dataSetA: Dataset[Row] = ??? // データの欠落は許容されない＝欠落時は例外で落としてOK\nval optDataSetB: Option[Dataset[Row]] = ??? // データの欠落を許容している為、Option\nval optDataSetC: Option[Dataset[Row]] = ??? // データの欠落を許容している為、Option\n \n// 同じスキーマを持ったデータA,B,Cをマージ\nval mergedDataSet = List(optDataSetB, optDataSetC)\n  .flatten\n  .foldLeft(dataSetA)(_ union _)\n</pre>\n\n\n<p>※わかりやすいように一部内容を変えてます</p>\n\n\n\n<p>さて、<code>Dataset[Row]</code>&nbsp;やそのメソッドである&nbsp;<code>union</code>&nbsp;(<code>foldLeft</code>&nbsp;内で呼んでる)はApache Spark SQLのAPIに関連する機能なので、今回は分かりやすくScala標準の文字列リストを使う事にします。</p>\n\n\n\n<p>まずはお馴染み、Scala REPLを開いて適当に文字列リストを2つ初期化します:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; val listA = List(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;)\nlistA: List[String] = List(Alice, Bob, Charlie)\n\nscala&gt; val listB = List(&quot;Dave&quot;, &quot;Eric&quot;, &quot;Frank&quot;)\nlistB: List[String] = List(Dave, Eric, Frank)\n</pre>\n\n\n<p>この2つを結合する場合、通常&nbsp;<code>++</code>&nbsp;を使います:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; val merged = listA ++ listB\nmerged: List[String] = List(Alice, Bob, Charlie, Dave, Eric, Frank)\n</pre>\n\n\n<p>これが、Spark SQLの例で言う&nbsp;<code>union</code>&nbsp;に相当しています。<br>さて、それではもう少し例に近づけて、リストが取得できないケースを考えてみます。この例ではリストの型は&nbsp;<code>List[String]</code>&nbsp;ですが、失敗した時は&nbsp;<code>null</code>&nbsp;を返すとします。（Scalaでは&nbsp;<code>null</code>&nbsp;は基本使いませんが）</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; val listC = null // リストの取得に失敗した想定。例えば読み取り元が存在しないファイルの為、IOエラーがあった時とか。\nlistC: Null = null\n</pre>\n\n\n<p>nullなので結合しようとすると、当然エラーが出ます:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nval merged = listA ++ listB ++ listC\njava.lang.NullPointerException\n  at scala.collection.immutable.List.$plus$plus(List.scala:209)\n  ... 28 elided\n</pre>\n\n\n<p>先程も言いましたが、Scalaでは&nbsp;<code>null</code>&nbsp;を使う事は基本無く、正常系/異常系を表現する場合は&nbsp;<code>Option[A]</code>&nbsp;等を使います。kojiがやっていたプロジェクトでは&nbsp;<code>Option[A]</code>&nbsp;を使っていたので、これを先程の3つのリストに当てはめるとこうなります:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; val optListA: Option[List[String]]  = Option(List(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;))\noptListA: Option[List[String]] = Some(List(Alice, Bob, Charlie))\n\nscala&gt; val optListB: Option[List[String]] = Option(List(&quot;Dave&quot;, &quot;Eric&quot;, &quot;Frank&quot;))\noptListB: Option[List[String]] = Some(List(Dave, Eric, Frank))\n\nscala&gt; val optListC: Option[List[String]] = Option(null)\noptListC: Option[List[String]] = None\n</pre>\n\n\n<p>※出力時の型の表記を揃えるため型アノテーションをあえてつけてます</p>\n\n\n\n<p>以下、<code>Option[A]</code>&nbsp;についてのおさらいになります。</p>\n\n\n\n<p>まず、&nbsp;<code>Option()</code>&nbsp;でラップするだけで、値があれば&nbsp;<code>Some[A]</code>&nbsp;に、無ければ&nbsp;<code>None</code>&nbsp;にそれぞれ変換してくれます。どちらも&nbsp;<code>Option[A]</code>&nbsp;の派生クラスです。<br>さて、先程のリストの結合ですが、リストは <code>Option</code> にラップされてる為、このままでは演算ができません。なので、値を取り出す必要があります。取り出す方法はいくつかありますが、一番シンプルなのは&nbsp;<code>get</code>&nbsp;を使う事です:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; optListA.get\nresXX: List[String] = List(Alice, Bob, Charlie)\n</pre>\n\n\n<p>ただし、値が&nbsp;<code>None</code>&nbsp;だった場合、例外が投げられます:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; optListC.get\njava.util.NoSuchElementException: None.get\n  at scala.None$.get(Option.scala:366)\n  at scala.None$.get(Option.scala:364)\n  ... 28 elided\n</pre>\n\n\n<p>と言う訳で、<code>get</code>&nbsp;を安直に使う事はなく、&nbsp;<code>isEmpty</code>&nbsp;を使って&nbsp;<code>None</code>&nbsp;でないかを判定するか、&nbsp;<code>getOrElse(default)</code>&nbsp;を使ったり、パターンマッチを使ったりで異常系の場合の例外処理を記載します。<br>以下は全部同じような意味になります:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; if (optListC.isEmpty) Nil else optListC.get\nresXX: List[String] = List()\n\nscala&gt; optListC.getOrElse(Nil)\nresXX: List[String] = List()\n\nscala&gt; optListC match { case Some(n) =&gt; n case None =&gt; Nil }\nresXX: List[String] = List()\n</pre>\n\n\n<p>さて、今回はこの様に値が複数あって、&nbsp;<code>Some[A]</code>&nbsp;の物だけ集めて&nbsp;<code>++</code>&nbsp;で結合したいと言うのが要件でしたね。<br>単純に、先程の例で安全にリストを取り出して結合しても良いですが、今回kojiがそうした様にListで更にラップするのも有りです:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; List(optListA, optListB, optListC).filter(_.nonEmpty).map(_.get).reduce(_ ++ _)\nresXX: List[String] = List(Alice, Bob, Charlie, Dave, Eric, Frank)\n</pre>\n\n\n<p>一応上記で何が起きているのか詳しく見てみましょう:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; val optLists = List(optListA, optListB, optListC) // List でOption[List[String]] をラップ\noptLists: List[Option[List[String]]] = List(Some(List(Alice, Bob, Charlie)), Some(List(Dave, Eric, Frank)), None)\n\nscala&gt; val nonEmptyOptLists = optLists.filter(_.nonEmpty) // 各Option[List[String]]のうち、 `nonEmpty` が真の物だけピックアップ\nnonEmptyOptLists: List[Option[List[String]]] = List(Some(List(Alice, Bob, Charlie)), Some(List(Dave, Eric, Frank)))\n\nscala&gt; val nonEmptyLists = nonEmptyOptLists.map(_.get) // 各Some[List[String]]から `get` で値を取り出し、リストに戻す\nnonEmptyLists: List[List[String]] = List(List(Alice, Bob, Charlie), List(Dave, Eric, Frank))\n\nscala&gt; val mergedList = nonEmptyLists.reduceLeft(_ ++ _) // 各List[String]を `++` で繋いでいく。\nmergedList: List[String] = List(Alice, Bob, Charlie, Dave, Eric, Frank)\n</pre>\n\n\n<p>これで安全にリストの結合ができました。しかし、実はこの処理、冒頭での例の通り、&nbsp;<code>.filter(_.nonEmpty).map(_.get)</code>&nbsp;の部分は単に&nbsp;<code>.flatten</code>&nbsp;に置き換える事ができます:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; val nonEmptyLists = List(optListA, optListB, optListC).flatten\nnonEmptyLists: List[List[String]] = List(List(Alice, Bob, Charlie), List(Dave, Eric, Frank))\n\nscala&gt; List(optListA, optListB, optListC).flatten == List(optListA, optListB, optListC).filter(_.nonEmpty).map(_.get)\nresXX Boolean = true\n</pre>\n\n\n<p>ところで、<code>List.flatten</code>&nbsp;と言うと、2次元配列&nbsp;<code>List[List[A]]</code>&nbsp;を&nbsp;<code>List[A]</code>&nbsp;に平坦化すると言うイメージが有り、実際にScaladocにもそのような例があります:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; List(Set(1, 2, 3), Set(1, 2, 3)).flatten\nresXX: List[Int] = List(1, 2, 3, 1, 2, 3)\n\nscala&gt; Set(List(1, 2, 3), List(1, 2, 3)).flatten // Setは重複なし\nresXX: scala.collection.immutable.Set[Int] = Set(1, 2, 3) \n</pre>\n\n\n<p>では何故、&nbsp;<code>List[Option[A]]</code>&nbsp;をflattenすると、Noneを排除した上で中身を取り出したリストが作られるのでしょう？<br>前置きが長くなりましたが、本題に入ります。</p>\n\n\n\n<h2 id=\"ListOptionAflattenの動きをみてみる\"><a href=\"https://hackmd.io/g_J2sY9VQy-EobTpM2Pd7Q?view#ListOptionAflatten%E3%81%AE%E5%8B%95%E3%81%8D%E3%82%92%E3%81%BF%E3%81%A6%E3%81%BF%E3%82%8B\"></a>List[Option[A]].flattenの動きをみてみる</h2>\n\n\n\n<p>話をシンプルにする為、実際に自分で <code>Option[A]</code> を実装してみます。<br>機能はごくシンプルに、ひとまず <code>get</code> と <code>isEmpty</code> のみ実装しました:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nsealed trait MyOption[+A] {\n  def isEmpty: Boolean\n  def get: A\n}\n\nfinal case class MySome[+A](value: A) extends MyOption[A] {\n  override def isEmpty: Boolean = false\n  override def get: A = value\n}\n\ncase object MyNone extends MyOption[Nothing] {\n  override def isEmpty: Boolean = true\n  override def get: Nothing = throw new Exception(&quot;You cannot get any value from MyNone&quot;)\n}\n</pre>\n\n\n<p>早速値を入れてみましょう:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; val optLists = List(MySome(List(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;)), MyNone, MySome(List(&quot;Dave&quot;, &quot;Eric&quot;, &quot;Frank&quot;)))\noptLists: List[Product with Serializable with MyOption[List[String]]] = List(MySome(List(Alice, Bob, Charlie)), MyNone, MySome(List(Dave, Eric, Frank)))\n</pre>\n\n\n<p>これで準備完了、とはいきません。何故なら、&nbsp;<code>List#flatten</code>&nbsp;(厳密には&nbsp;<code>GenericTraversableTemplate#flatten</code>) は第1引数に、&nbsp;<code>A =&gt; GenTraversableOnce[B]</code>&nbsp;型の関数を暗黙的に受け取る (Implicit Parameter) からです:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\ndef flatten[B](implicit asTraversable: A =&gt; GenTraversableOnce[B]): List[B] // List#flatten の返り値は `List[B]`\n</pre>\n\n\n<p>※Implicit Parameterは<a href=\"http://dwango.github.io/scala_text_previews/trait-tut/implicit.html#implicit-parameter%EF%BC%88%E2%98%85%E2%98%85%E2%98%85%EF%BC%89\" target=\"_blank\" rel=\"noreferrer noopener\">ドワンゴさんのScala研修テキスト</a>が詳しいです</p>\n\n\n\n<p>この時点でのREPLのコンテキストでは暗黙的にパラメーターを渡せず、明示的に渡す必要があるので、早速作ってみましょう。</p>\n\n\n\n<p>まず、現コンテキスト上では&nbsp;<code>A</code>&nbsp;はListの要素である&nbsp;<code>MyOption[List[String]]</code>&nbsp;なので、これをイテレーション可能な&nbsp;<code>GenTraversableOnce[B]</code>&nbsp;互換の値 (例えば <code>List[B]</code> とか) に変換する関数にする必要があります。&nbsp;<code>B</code>&nbsp;は<code>A</code>&nbsp;がラップしている物、つまり&nbsp;<code>List[String]</code>&nbsp;になります。つまり、&nbsp;<code>A =&gt; GenTraversableOnce[B]</code>&nbsp;はこの場合は&nbsp;<code>MyOption[List[String]] =&gt; GenTraversableOnce[List[String]]</code>&nbsp;と言えます。</p>\n\n\n\n<p>では、 <code>MyOption</code> でイテレーション可能な表現とはどの様な物でしょうか？おそらく、&nbsp;<code>MySome(\"Alice\")</code>&nbsp;であればそのまま中身の&nbsp;<code>\"Alice\"</code>&nbsp;だけを反復する&nbsp;<code>List(\"Alice\")</code>&nbsp;のような値、&nbsp;<code>MyNone</code>&nbsp;であれば、1回も反復を行わない&nbsp;<code>List() = Nil</code>&nbsp;のような値が妥当に思えます。 (繰り返しますが、GenTraversableOnce互換であれば必ずしもListである必要は無いです)</p>\n\n\n\n<p>以上を踏まえると、今回渡す関数は次のような物で良さそうです:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nMyOption[List[String]] =&gt; if (opt.isEmpty) Nil else List(opt.get)\n</pre>\n\n\n<p>実際にREPLで実行してみます:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; val nonEmptyLists = optLists.flatten((opt: MyOption[List[String]]) =&gt; if (opt.isEmpty) Nil else List(opt.get))\nnonEmptyLists: List[List[String]] = List(List(Alice, Bob, Charlie), List(Dave, Eric, Frank))\n\nscala&gt; val merged = nonEmptyLists.reduceLeft(_ ++ _)\nmerged: List[String] = List(Alice, Bob, Charlie, Dave, Eric, Frank)\n</pre>\n\n\n<p>うまくいきました！</p>\n\n\n\n<p>最後に、&nbsp;<code>flatten</code>&nbsp;の暗黙パラメーターをどう渡すかを考える必要があります。</p>\n\n\n\n<p>ところで先程の&nbsp;<code>MyOption</code>&nbsp;を&nbsp;<code>GenTraversableOnce[B]</code>&nbsp;な表現にする、と言う処理ですが実は本家の&nbsp;<code>Option</code>&nbsp;は既にこれを満たす&nbsp;<code>toList</code>&nbsp;を持っています:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\n// scala.Option#toList\n\n/** Returns a singleton list containing the $option's value\n * if it is nonempty, or the empty list if the $option is empty.\n */\ndef toList: List[A] = if (isEmpty) List() else new ::(this.get, Nil)\n</pre>\n\n\n<p>なのでこれに習って、こちらでも先程作った関数を&nbsp;<code>toList</code>&nbsp;として定義しておきます:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nsealed trait MyOption[+A] {\n  def isEmpty: Boolean\n  def get: A\n  def toList: List[A] = if (isEmpty) Nil else List(get)\n}\n\nfinal case class MySome[+A](value: A) extends MyOption[A] {\n  override def isEmpty: Boolean = false\n  override def get: A = value\n}\n\ncase object MyNone extends MyOption[Nothing] {\n  override def isEmpty: Boolean = true\n  override def get: Nothing = throw new Exception(&quot;You cannot get any value from MyNone&quot;)\n}\n</pre>\n\n\n<p>REPLで実行するとこんな感じです:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; MySome(&quot;Alice&quot;).toList\nresXX: List[String] = List(Alice)\n\nscala&gt; MyNone.toList\nresXX: List[Nothing] = List()\n</pre>\n\n\n<p>ばっちりですね。後は、これを&nbsp;<code>flatten</code>&nbsp;に暗黙的に渡すだけです。本家のOptionでは、コンパニオンオブジェクトである&nbsp;<code>Option</code>&nbsp;オブジェクトにてImplicit Conversion (暗黙的な変換) を定義する事で実現しています:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nobject Option {\n\n  import scala.language.implicitConversions\n\n  /** An implicit conversion that converts an option to an iterable value\n   */\n  implicit def option2Iterable[A](xo: Option[A]): Iterable[A] = xo.toList // IterableはGenTraversableOnceの派生\n  \n  // 以下略\n}\n</pre>\n\n\n<p>※Implicit Conversionについても<a href=\"http://dwango.github.io/scala_text_previews/trait-tut/implicit.html#implicit-conversion%EF%BC%88%E2%98%85%E2%98%85%E2%98%85%EF%BC%89\" target=\"_blank\" rel=\"noreferrer noopener\">ドワンゴさんのScala研修テキスト</a>を参照下さい</p>\n\n\n\n<p>例によって我々もコンパニオンオブジェクトを用意して、Implicit Conversionを実装しましょう:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nobject MyOption {\n  import scala.language.implicitConversions\n\n  implicit def opt2List[A](opt: MyOption[A]): List[A] = opt.toList\n\n  // ついでに `apply` も実装して初期化しやすくする\n  def apply[A](value: A): MyOption[A] = if (value == null) MyNone else MySome(value)\n}\n\nsealed trait MyOption[+A] {\n  def isEmpty: Boolean\n  def get: A\n  def toList: List[A] = if (isEmpty) Nil else List(get)\n}\n\nfinal case class MySome[+A](value: A) extends MyOption[A] {\n  override def isEmpty: Boolean = false\n  override def get: A = value\n}\n\ncase object MyNone extends MyOption[Nothing] {\n  override def isEmpty: Boolean = true\n  override def get: Nothing = throw new Exception(&quot;You cannot get any value from MyNone&quot;)\n}\n</pre>\n\n\n<p>REPLで実行してみます:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; MyOption(&quot;Alice&quot;).toList\nresXX: List[String] = List(Alice)\n\nscala&gt; MyOption(null).toList\nresXX: List[Null] = List()\n</pre>\n\n\n<p>MyOptionはListに暗黙的に変換できます。なので、実際には定義されていない、&nbsp;<code>++</code>&nbsp;等のListのメソッドを使う事ができます:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; MyOption(&quot;Alice&quot;) ++ List(&quot;Bob&quot;) ++ List(&quot;Charlie&quot;)\nresXX: List[String] = List(Alice, Bob, Charlie)\n\nscala&gt; MyOption(null) ++ List(&quot;Bob&quot;) ++ List(&quot;Charlie&quot;)\nresXX: List[String] = List(Bob, Charlie)\n</pre>\n\n\n<p>では最後に、今回のテーマである&nbsp;<code>flatten</code>&nbsp;を交えて実行してみましょう:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nscala&gt; val optLists = List(MyOption(List(&quot;Alice&quot;, &quot;Bob&quot;, &quot;Charlie&quot;)), MyOption(null), MyOption(List(&quot;Dave&quot;, &quot;Eric&quot;, &quot;Frank&quot;)))\noptLists: List[MyOption[List[String]]] = List(MySome(List(Alice, Bob, Charlie)), MyNone, MySome(List(Dave, Eric, Frank)))\n\nscala&gt; val nonEmptyLists = optLists.flatten\nnonEmptyLists: List[List[String]] = List(List(Alice, Bob, Charlie), List(Dave, Eric, Frank))\n\nscala&gt; val merged = nonEmptyLists.reduceLeft(_ ++ _)\nmerged: List[String] = List(Alice, Bob, Charlie, Dave, Eric, Frank)\n</pre>\n\n\n<p>無事できました。<br>以上、長くなりましたが解説を終わります。</p>\n","dateObject":"2019-11-01T03:00:29.000Z","date":"November 01, 2019","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"flatten","slug":"flatten"},{"name":"Option","slug":"option"},{"name":"Scala","slug":"scala"}],"author":{"name":"issei_m","slug":"issei"},"featured_media":{"media_details":{"sizes":{"large":{"source_url":"https://i0.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/10/Screen-Shot-2019-10-23-at-17.48.40.png?fit=1024%2C181&ssl=1","height":181,"width":1024},"medium_large":{"source_url":"https://i0.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/10/Screen-Shot-2019-10-23-at-17.48.40.png?fit=768%2C136&ssl=1","height":136,"width":768}}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2019/10/Screen-Shot-2019-10-23-at-17.48.40.png"},"wordpress_id":1206}},"pageContext":{"id":"9563bb53-db10-5e3c-97af-4bfc61ed02e6","nextPath":"/2019/10/24/option（scala）の実用的な使い方-−-データのマージ処理/","nextTitle":"Option（Scala）の実用的な使い方 − データのマージ処理","prevPath":"/2019/11/11/switch-from-mac-to-windows/","prevTitle":"Mac から Windows に乗り換え"}}}