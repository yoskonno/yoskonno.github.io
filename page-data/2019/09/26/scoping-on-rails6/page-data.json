{"componentChunkName":"component---src-templates-post-js","path":"/2019/09/26/scoping-on-rails6/","result":{"data":{"wordpressPost":{"id":"838ef3ec-6017-5532-bbf1-1af6a7836031","title":"Rails 6からActiveRecordのAssociationはscopingの影響を受けなくなっている件と対処法","excerpt":"<p>こんにちは。日本ではすっかり秋の空が近づいてきました。個人的に夏は暑さが苦手であまり好きではないのですが、終わってしまうとなると毎年どこか寂しい気持ちになります。一方で、秋はご飯が美味しいので食べる事が好きな僕にとっては [&hellip;]</p>\n","slug":"scoping-on-rails6","content":"\n<p>こんにちは。日本ではすっかり秋の空が近づいてきました。個人的に夏は暑さが苦手であまり好きではないのですが、終わってしまうとなると毎年どこか寂しい気持ちになります。<br>一方で、秋はご飯が美味しいので食べる事が好きな僕にとっては一番好きな季節でもあり、結構心が踊っています。笑</p>\n\n\n\n<p>さて、前置きは置いといて今回は表題の通り、とあるRails 5.2プロジェクトをRails 6にアップグレードした際に、ActiveRecordのscopingの仕様変更を踏んでしまったのでその対処法をご紹介します。</p>\n\n\n\n<h2 id=\"そもそもscopingとは\"><a href=\"https://hackmd.io/XFZ8htrMQ_KdpEFxk0tuNg?view#%E3%81%9D%E3%82%82%E3%81%9D%E3%82%82scoping%E3%81%A8%E3%81%AF\"></a>そもそもscopingとは</h2>\n\n\n\n<p><code>ActiveRecord::Relation</code>&nbsp;の機能で、引数にブロックを受け取り、その中では、実行時に適用されていたスコープを全クエリでデフォルトで適用する、と言う物になります。<br>例として、<code>deleted_at (timestamp, nullable)</code>&nbsp;と言うattributeを持つモデル&nbsp;<code>Blog</code>&nbsp;があるとします。このカラムに日時が入っている場合、その記事は論理削除されている物とします。</p>\n\n\n\n<p>この時、論理削除されていないデータを返すスコープは次の通りなるかと思います:</p>\n\n\n<pre class=\"brush: ruby; title: ; notranslate\" title=\"\">\nclass Blog\n  scope :not_deleted, -&gt; { where(deleted_at: nil) }\nend\n</pre>\n\n\n<p>割とよくある実装ですね。（個人的に論理削除はあまり好まないですが今回遭遇したケースを簡単に説明する為にあえて題材として選んでいます）</p>\n\n\n\n<p>エンドユーザーに見せる画面では、基本的に削除済みのデータは出してはいけないと思うので基本的にこのスコープを使う事になると思いますが、後から書くコードでそれを継続的に徹底するのは中々チャレンジングかと思います。</p>\n\n\n\n<p>そこで、先の通りActiveRecordにはscopingと言う機能があるので、これを、<code>ActionController::Base</code>&nbsp;の&nbsp;<code>around_action</code>&nbsp;機能と組み合わせて、横断的に論理削除データを結果から排除すると言うテクニックがあります。</p>\n\n\n\n<p>参考：<a href=\"http://attracie.hatenablog.com/entry/2016/12/16/175614\" target=\"_blank\" rel=\"noreferrer noopener\">default_scopeよりaround_actionとscopingを使おう</a></p>\n\n\n\n<p>例えば、エンドユーザーが使う機能は以下の&nbsp;<code>EndUserBaseController</code>&nbsp;を必ず継承するとします:</p>\n\n\n<pre class=\"brush: ruby; title: ; notranslate\" title=\"\">\nclass EndUserBaseController &lt; ApplicationController\n  around_action :set_scope, if: :block_users_present?\n\n  private def set_scope\n    Blog.not_deleted.scoping { yield }\n  end\nend\n</pre>\n\n\n<p>こうすると、全てのアクションはこの&nbsp;<code>set_scope</code>&nbsp;内で呼び出している&nbsp;<code>scoping</code>&nbsp;ブロックの中で実行される事になります。<br>つまり、全てのアクションで、&nbsp;<code>Blog</code>&nbsp;モデルのクエリは&nbsp;<code>deleted_at IS NULL</code>&nbsp;の条件が付き、削除済みのデータが表示される心配が無くなります。<br>なお、ブロックの後はスコープは解除されるので、外の機能に影響を与えません。</p>\n\n\n\n<p>また、scopingは結構かしこくて、設定したスコープはAssociationに対しても有効です（※後述しますがこの認識は誤りです）。例えば&nbsp;<code>Blog</code>&nbsp;はhasManyな&nbsp;<code>BlogComment</code>&nbsp;へのAssociationを持つとします:</p>\n\n\n<pre class=\"brush: ruby; title: ; notranslate\" title=\"\">\nclass Blog\n  has_many :comments, class_name: &quot;BlogComment&quot;, inverse_of: :blog\nend\n\nclass BlogComment\n  belongs_to :blog, inverse_of: :comments\nend\n</pre>\n\n\n<p>先程設定したscopingの中では、以下のようにしても論理削除されたデータは表示されません:</p>\n\n\n<pre class=\"brush: ruby; title: ; notranslate\" title=\"\">\nBlog.find(1).save!(deleted_at: Time.now) # id=1のBlogは論理削除済み\n\nBlog.not_deleted.scoping do\n  # `blog` associationの解決には `SELECT * FROM blogs WHERE id = 1 AND deleted_at IS NULL` の様なクエリが実行される。\n  BlogComment.where(blog_id: 1).blog # nil\nend\n\nBlogComment.where(blog_id: 1).blog # ここではid=1のBlogが返る\n</pre>\n\n\n<p>また、当たり前ですがブロックはネストさせる事ができるので、論理削除するモデルが複数ある場合でも次のように書く事ができます:</p>\n\n\n<pre class=\"brush: ruby; title: ; notranslate\" title=\"\">\nBlog.not_deleted.scoping do\n  BlogComment.not_deleted.scoping do\n    yield \n  end\nend\n</pre>\n\n\n<p><code>Blog</code>&nbsp;だけでなく、&nbsp;<code>BlogComment</code>&nbsp;の論理削除もこれでバッチリです。やったね★</p>\n\n\n\n<h2 id=\"しかし、Rails-6では…\"><a href=\"https://hackmd.io/XFZ8htrMQ_KdpEFxk0tuNg?view#%E3%81%97%E3%81%8B%E3%81%97%E3%80%81Rails-6%E3%81%A7%E3%81%AF%E2%80%A6\"></a>しかし、Rails 6では…</h2>\n\n\n\n<p>仕様が変更された為、先程のコードはそのままでは動きません。具体的には、</p>\n\n\n<pre class=\"brush: ruby; title: ; notranslate\" title=\"\">\nBlog.not_deleted.scoping do\n  BlogComment.where(blog_id: 1).blog\nend\n</pre>\n\n\n<p>は&nbsp;<code>nil</code>&nbsp;を返しません。&nbsp;<code>BlogComment.blog</code>&nbsp;のAssociation解決時に実行される&nbsp;<code>Blog</code>&nbsp;モデルへのSELECTクエリへのスコープがリセットされ、<code>deleted_at IS NULL</code>&nbsp;の条件が消える為です。<br>これは一見バグに見えますが、CHANGELOGにも記載してある為、どうやら仕様変更のようです。</p>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>Association loading isn’t to be affected by scoping consistently whether preloaded / eager loaded or not, with the exception of unscoped.</p><p>Before:</p><p>Post.where(&#8220;1=0&#8221;).scoping do<br>&nbsp;&nbsp;Comment.find(1).post                   # =&gt; nil<br>&nbsp;&nbsp;Comment.preload(:post).find(1).post    # =&gt; #<br>&nbsp;&nbsp;Comment.eager_load(:post).find(1).post # =&gt; #<br>end</p><p>After:</p><p>Post.where(&#8220;1=0&#8221;).scoping do<br>&nbsp;&nbsp;Comment.find(1).post                   # =&gt; #<br>&nbsp;&nbsp;Comment.preload(:post).find(1).post    # =&gt; #<br>&nbsp;&nbsp;Comment.eager_load(:post).find(1).post # =&gt; #<br>end</p><cite>※CHANGELOGより:&nbsp;<a rel=\"noreferrer noopener\" href=\"https://github.com/rails/rails/blob/v6.0.0/activerecord/CHANGELOG.md\" target=\"_blank\">https://github.com/rails/rails/blob/v6.0.0/activerecord/CHANGELOG.md</a></cite></blockquote>\n\n\n\n<p>Associationの読み込みは&nbsp;<code>unscoped</code>&nbsp;以外のスコープの影響を受けないと明記されています。（記載はされていませんが <code>default_scope</code> は有効です）</p>\n\n\n\n<p>具体的なコードの変更点は以下のようです:</p>\n\n\n\n<p><strong>Rails 5.2</strong></p>\n\n\n<pre class=\"brush: ruby; highlight: [6]; title: ; notranslate\" title=\"\">\n# https://github.com/rails/rails/blob/v5.2.3/activerecord/lib/active_record/associations/association.rb#L135\n\n# Can be overridden (i.e. in ThroughAssociation) to merge in other scopes (i.e. the\n# through association's scope)\ndef target_scope\n  AssociationRelation.create(klass, self).merge!(klass.all)\nend\n</pre>\n\n\n<p><strong>Rails 6.0</strong></p>\n\n\n<pre class=\"brush: ruby; highlight: [6]; title: ; notranslate\" title=\"\">\n# https://github.com/rails/rails/blob/v5.2.3/activerecord/lib/active_record/associations/association.rb#L135\n\n# Can be overridden (i.e. in ThroughAssociation) to merge in other scopes (i.e. the\n# through association's scope)\ndef target_scope\n  AssociationRelation.create(klass, self).merge!(klass.scope_for_association)\nend\n</pre>\n\n\n<p><code>AssociationRelation</code>&nbsp;オブジェクト初期化時のデフォルトスコープとして、これまでは&nbsp;<code>klass.all</code>&nbsp;(<code>current_scope</code>&nbsp;を含む) であった物が、&nbsp;<code>klass.scope_for_association</code>&nbsp;(<code>current_scope</code>&nbsp;を含まない) に変更されています。</p>\n\n\n\n<p>この変更については、<a rel=\"noreferrer noopener\" href=\"https://github.com/rails/rails/pull/35868\" target=\"_blank\">該当のPullReq</a>から経緯を追う事ができます。<br>まず、<a rel=\"noreferrer noopener\" href=\"https://github.com/rails/rails/pull/18109\" target=\"_blank\">このPullReq</a>で&nbsp;<code>unscoped</code>&nbsp;がAssociation解決時にも適用されるようになったようです:</p>\n\n\n<pre class=\"brush: ruby; title: ; notranslate\" title=\"\">\n# Fooのdefault_scopeがwhere(status: 1)の時、以下のクエリは\n# Before: SELECT bar.* FROM bar INNER JOIN foo ON foo.id = bar.foo_id AND foo.status = 1\n# After: SELECT bar.* FROM bar INNER JOIN foo ON foo.id = bar.foo_id\nFoo.unscoped { Bar.joins(:foo).to_sql }\n</pre>\n\n\n<p>Beforeでは&nbsp;<code>unscoped</code>&nbsp;が意図した通り動いていなかったので、妥当な修正と言えます。<br>しかし、この変更により、<code>Foo.current_scope</code>&nbsp;が&nbsp;<code>Bar.joins(:foo)</code>&nbsp;に適用される結果となってしまい、これが意図してなかった様で、<a href=\"https://github.com/rails/rails/commit/5c71000d086cc42516934415b79380c2224e1614\" target=\"_blank\" rel=\"noreferrer noopener\">このcommit</a>にてそれが修正されています:</p>\n\n\n<pre class=\"brush: ruby; title: ; notranslate\" title=\"\">\n# Before: SELECT bar.* FROM bar INNER JOIN foo ON foo.id = bar.foo_id AND foo.status = 1\n# After: SELECT bar.* FROM bar INNER JOIN foo ON foo.id = bar.foo_id\nFoo.where(status: 1).scoping { Bar.joins(:foo).to_sql }\n</pre>\n\n\n<p>ここまではRails 5.2にも適用されているので、先に紹介した&nbsp;<code>scoping</code>&nbsp;を使った横断的な条件の適用はRailsの意図する使い方ではなかったと言う事が分かります。<br>現に、先に紹介した<a href=\"http://attracie.hatenablog.com/entry/2016/12/16/175614\" target=\"_blank\" rel=\"noreferrer noopener\">default_scopeよりaround_actionとscopingを使おう</a>の書き込み日が2016年12月となっており、<code>unscoped</code>&nbsp;の修正は同年2月の為、偶然にも意図していない手法を使ってしまった物と思われます。（<code>current_scope</code>&nbsp;をAssociationに波及させない修正は翌年）</p>\n\n\n\n<p>とは言え、ActiveRecordの開発動向を追っていない限りこの手の誤りは致し方ない事だと言えます。</p>\n\n\n\n<p>さて、以上を踏まえた上で、最初の<a href=\"https://github.com/rails/rails/pull/35868\" target=\"_blank\" rel=\"noreferrer noopener\">PullReq</a>に戻ると話が繋がります。このパッチはRails 6.0以降にしか当たっていないのですが、要は&nbsp;<code>joins</code>,&nbsp;<code>preload</code>,&nbsp;<code>eager_load</code>&nbsp;等のAssociation解決時に&nbsp;<code>current_scope</code>&nbsp;を引き繋がないのと同様に、遅延読み込み時にも同様に&nbsp;<code>current_scope</code>&nbsp;を支持しない様修正が加えられた様です。</p>\n\n\n\n<p>CHANGELOGを再掲しますが、一目瞭然です:</p>\n\n\n<pre class=\"brush: ruby; title: ; notranslate\" title=\"\">\nPost.where(&quot;1=0&quot;).scoping do\n  Comment.find(1).post                   # =&gt; #&lt;Post id: 1, ...&gt;\n  Comment.preload(:post).find(1).post    # =&gt; #&lt;Post id: 1, ...&gt;\n  Comment.eager_load(:post).find(1).post # =&gt; #&lt;Post id: 1, ...&gt;\nend\n</pre>\n\n\n<h2 id=\"対処療法として\"><a href=\"https://hackmd.io/XFZ8htrMQ_KdpEFxk0tuNg?view#%E5%AF%BE%E5%87%A6%E7%99%82%E6%B3%95%E3%81%A8%E3%81%97%E3%81%A6\"></a>対処療法として</h2>\n\n\n\n<p>と言う訳で、タイトルのテクニックはRails的には誤りだった訳ですが、既に運用中のソフトウェアでこの問題を横断的に対処するのは非常に骨が折れます。<br>なので、「今回僕が関わったプロジェクトではこうした」と言う対処療法的なバッドノウハウをご紹介します。あくまでバッドノウハウなので使用には注意が必要です。</p>\n\n\n\n<p><strong>基本方針</strong></p>\n\n\n\n<p>先のPullReqの経緯を追うと、<code>default_scope</code>&nbsp;およびそれを解除する&nbsp;<code>unscoped</code>&nbsp;についてはAssociationに波及させるのが意図した動作の様です。<br>なので、今回は古き良き&nbsp;<code>default_scope</code>&nbsp;を使う事にしました。実際に論理削除を実現するGemである<a href=\"https://github.com/ActsAsParanoid/acts_as_paranoid\" target=\"_blank\" rel=\"noreferrer noopener\">acts_as_paranoid</a>では、<a href=\"https://github.com/ActsAsParanoid/acts_as_paranoid/blob/30c8b6a18a650bad6cdd4943af037d4ac970f886/lib/acts_as_paranoid.rb#L36\" target=\"_blank\" rel=\"noreferrer noopener\">default_scopeを使っているようで、</a>このコードでRails 6でも動作するみたいです。</p>\n\n\n\n<p>とは言え、元はと言えば <code>scoping</code> によるテクニックは<a rel=\"noreferrer noopener\" href=\"http://attracie.hatenablog.com/entry/2016/12/16/175614\" target=\"_blank\">default_scope is evil</a>、つまりむやみやたと <code>default_scope</code> を使う事を止めようキャンペーンが元になっているので、できればこれは使わないでおきたい（なぜなら論理削除を表示したい場合もあり、その様なケースで <code>unscoped</code> を徹底するのはナンセンスなので）です。<br>ではどうしたかと言うと、 <code>default_scope</code> が複数指定できる性質を活かし、「<code>scoping</code> を論理削除の為に使う」と言う誤った使い方ではあるがその使い勝手を尊重し、次のようにしました:</p>\n\n\n<pre class=\"brush: ruby; title: ; notranslate\" title=\"\">\nclass EndUserBaseController &lt; ApplicationController\n  around_action :set_scope\n\n  private\n\n  def set_scope\n    persistent_scoping(Blog.not_deleted) { yield }\n  end\n\n  # 受け取ったscopeを維持しながらblockを実行する.\n  # `ActiveRecord::Relation.scoping` とは異なり、Associationに対してもscopeは維持される.\n  #\n  # ex)\n  #   User.where('0=0').scoping { Post.first.user } # not nil\n  #   persistent_scoping(User.where('0=0')) { Post.first.user } # nil\n  def persistent_scoping(scope)\n    klass = scope.model\n    previous = klass.default_scopes\n    klass.default_scopes += [-&gt; { scope }]\n\n    logger.debug &quot;The default_scopes of #{klass} is expanded within the current action (#{previous.count} scope(s) had been set originally)&quot;\n\n    yield\n  ensure\n    klass.default_scopes = previous\n\n    logger.debug &quot;The expanded default_scopes of #{klass} within the current action has been recovered.&quot;\n  end\nend\n</pre>\n\n\n<p>ブロック実行前に一時的に&nbsp;<code>default_scope</code>&nbsp;に現在のスコープを適用し、ブロック実行後にもとに戻すと言う荒療治です。<br>しかし、これで元の&nbsp;<code>scoping</code>&nbsp;通り、ネストも可能ですし使い勝手は全く同じになりました。</p>\n","dateObject":"2019-09-26T01:00:17.000Z","date":"September 26, 2019","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"ActiveRecord","slug":"activerecord"},{"name":"Rails","slug":"rails"},{"name":"Rails6","slug":"rails6"}],"author":{"name":"issei_m","slug":"issei"},"featured_media":{"media_details":{"sizes":{"large":{"source_url":"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/09/Ruby_On_Rails_Logo.svg_.png?fit=1024%2C387&ssl=1","height":387,"width":1024},"medium_large":{"source_url":"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/09/Ruby_On_Rails_Logo.svg_.png?fit=768%2C290&ssl=1","height":290,"width":768}}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2019/09/Ruby_On_Rails_Logo.svg_.png"},"wordpress_id":1130}},"pageContext":{"id":"838ef3ec-6017-5532-bbf1-1af6a7836031","nextPath":"/2019/09/25/jmeter-on-k8s-eks/","nextTitle":"JMeter on k8s (EKS)","prevPath":"/2019/10/01/guiありのwebスクレイピングを定期実行する/","prevTitle":"GUIありのWebスクレイピングを定期実行する"}}}