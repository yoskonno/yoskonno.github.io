{"componentChunkName":"component---src-templates-post-js","path":"/2019/10/24/option（scala）の実用的な使い方-−-データのマージ処理/","result":{"data":{"wordpressPost":{"id":"f8ecc913-e925-500a-b6d7-8086b9e79d43","title":"Option（Scala）の実用的な使い方 − データのマージ処理","excerpt":"<p>いまいち使いどころを理解できていなかったScalaのOptionですが、データのマージ処理を実装した際に、割と理解しやすいコードが書けたと感じましたのでざっくりとですがご紹介します。 環境 Scala 2.11.12 s [&hellip;]</p>\n","slug":"option%ef%bc%88scala%ef%bc%89%e3%81%ae%e5%ae%9f%e7%94%a8%e7%9a%84%e3%81%aa%e4%bd%bf%e3%81%84%e6%96%b9-%e2%88%92-%e3%83%87%e3%83%bc%e3%82%bf%e3%81%ae%e3%83%9e%e3%83%bc%e3%82%b8%e5%87%a6%e7%90%86","content":"\n<p>いまいち使いどころを理解できていなかったScalaのOptionですが、データのマージ処理を実装した際に、割と理解しやすいコードが書けたと感じましたのでざっくりとですがご紹介します。</p>\n\n\n\n<h2>環境</h2>\n\n\n\n<ul><li>Scala  2.11.12</li><li>spark  2.4.3  </li><li>AWS EMR  5.26.0</li></ul>\n\n\n\n<h2>方針</h2>\n\n\n\n<p>マージを行うメイン処理がデータ取得する際に呼び出す関数の戻り値をDataset[Row]型ではなくOption[Dataset[Row]]型にすることで仕様変更に対応しました。これにより戻り値としてOption.empty[Dataset[Row]]を返せるようになるのですが、こうすることでどんなメリットがあるのかについては例を用いて説明したいと思います。</p>\n\n\n\n<h2>修正前の処理</h2>\n\n\n\n<p>以下のようなデータA,B,Cをマージするという処理において、result_b.csv、result_c.csvの２ファイルは必ず存在する前提で、なかった場合はExceptionを発生させて異常終了させるという仕様でしたので、関数readDataSetB、readDataSetCは直接Dataset[Row]型を返却していました。</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n  def mergeDataSet(): Unit = {\n    val dataSetA = readDataSetA\n\n    // 同じスキーマを持ったデータA,B,Cをマージ\n    val mergedDataSet = List(readDataSetB, readDataSetC)\n      .foldLeft(dataSetA)(_ union _)\n\n    // マージしたデータをCSVとしてS3に出力\n    fileIo.writeToS3(spark, mergedDataSet, s&quot;${fileIo.rootPath}/merged_data/${configurations.partition}/merged_data.csv&quot;)\n  }\n\n  def readDataSetB: Dataset[Row] = {\n      val schema = StructType($&quot;result_id&quot;.string :: $&quot;result_date&quot;.string)\n      spark.read.schema(schema)\n        .csv(s&quot;s3://$bucket/result/$partition/result_b.csv&quot;)\n  }\n\n  def readDataSetC: Dataset[Row] = {\n      val schema = StructType($&quot;result_id&quot;.string :: $&quot;result_date&quot;.string)\n      spark.read.schema(schema)\n        .csv(s&quot;s3://$bucket/result/$partition/result_c.csv&quot;)\n  }\n</pre>\n\n\n<p>しかし、後からresult_c.csvがない場合、処理を続行してしまって良いという仕様に変わったため、Exceptionをcatchしてエラーにならないようにすることにしました。</p>\n\n\n\n<p>ここでJavaであればDataset[Row]型の戻り値をnullで返したりするのでしょうが、Scalaではnullを扱わなくても済むようにOption型が存在しますので、これで対応します。</p>\n\n\n\n<h2>修正後の処理</h2>\n\n\n\n<p>変更の主な内容はtry~catch、Option()の追加ですが、６行目に追加したflatten関数がとても重要です。Option()の中の型で値を取り出してくれる関数なのですが、Option.empty[Dataset[Row]]だった場合はデータがないということでリストから削除してくれます。</p>\n\n\n\n<p>つまり、result_c.csvがない場合、データA,BがマージされデータCはないものとしてリスト処理されます。</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n  def mergeDataSet(): Unit = {\n    val dataSetA = readDataSetA\n\n    // 同じスキーマを持ったデータA,B,Cをマージ\n    val mergedDataSet = List(readDataSetB, readDataSetC)\n      .flatten\n      .foldLeft(dataSetA)(_ union _)\n\n    // マージしたデータをCSVとしてS3に出力\n    fileIo.writeToS3(spark, mergedDataSet, s&quot;${fileIo.rootPath}/merged_data/${configurations.partition}/merged_data.csv&quot;)\n  }\n\n  def readDataSetB: Option[Dataset[Row]] = {\n      val schema = StructType($&quot;result_id&quot;.string :: $&quot;result_date&quot;.string)\n      Option(\n        spark.read.schema(schema)\n          .csv(s&quot;s3://$bucket/result/$partition/result_b.csv&quot;)\n      )\n  }\n\n  def readDataSetC: Option[Dataset[Row]] = {\n      try {\n        val schema = StructType($&quot;result_id&quot;.string :: $&quot;result_date&quot;.string)\n        Option(\n          spark.read.schema(schema)\n            .csv(s&quot;s3://$bucket/result/$partition/result_c.csv&quot;)\n        )\n      } catch {\n        case e: AnalysisException =&gt; Option.empty[Dataset[Row]]\n      }\n  }\n</pre>\n\n\n<p>Option()とflatten関数を組み合わせることでシンプルで分かりやすいメソッドチェーンを組むことができる１つの例だと思います。</p>\n\n\n\n<h2>まとめ</h2>\n\n\n\n<p>Optionすごく便利ですが、そのメリットが非常に伝えずらい機能だなとも思います。新しい使い方を開拓してご報告できそうなら、また書きます。</p>\n","dateObject":"2019-10-24T00:00:27.000Z","date":"October 24, 2019","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"AWS","slug":"aws"},{"name":"EMR","slug":"emr"},{"name":"Scala","slug":"scala"},{"name":"Spark","slug":"spark"}],"author":{"name":"koji","slug":"koji"},"featured_media":{"media_details":{"sizes":{"large":{"source_url":"https://i0.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/10/Screen-Shot-2019-10-23-at-17.48.40.png?fit=1024%2C181&ssl=1","height":181,"width":1024},"medium_large":{"source_url":"https://i0.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/10/Screen-Shot-2019-10-23-at-17.48.40.png?fit=768%2C136&ssl=1","height":136,"width":768}}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2019/10/Screen-Shot-2019-10-23-at-17.48.40.png"},"wordpress_id":1185}},"pageContext":{"id":"f8ecc913-e925-500a-b6d7-8086b9e79d43","nextPath":"/2019/10/09/internal-study-sessions/","nextTitle":"社内勉強会が活発になってきた","prevPath":"/2019/11/01/things-what-happen-to-list-wrapped-option-flatten/","prevTitle":"(Scala) List[Option[A]]#flattenで起きる事"}}}