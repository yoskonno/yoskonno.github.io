{"componentChunkName":"component---src-templates-post-js","path":"/2020/08/17/lazy-collection-in-scala/","result":{"data":{"wordpressPost":{"id":"c6a5d80c-0590-56be-be61-09eae343ee44","title":"Scalaのコレクションで遅延処理を行う","excerpt":"<p>皆様おはようございます。梅雨もとっくに過ぎ、すっかり夏らしい空模様となりました。埼玉は毎日気温が高くて死にそうです・・・。 さて今回はScalaのコレクションネタです。結論から先に書くと、Scalaのコレクション処理 ( [&hellip;]</p>\n","slug":"lazy-collection-in-scala","content":"\n<p>皆様おはようございます。梅雨もとっくに過ぎ、すっかり夏らしい空模様となりました。埼玉は毎日気温が高くて死にそうです・・・。</p>\n\n\n\n<p>さて今回はScalaのコレクションネタです。<br>結論から先に書くと、Scalaのコレクション処理 (<code>map</code>,&nbsp;<code>flatMap</code>,&nbsp;<code>filter</code>等) は、 (<code>Stream</code>&nbsp;型を除いて) デフォルトでは遅延的に処理されません。遅延させたい場合は<a href=\"https://docs.scala-lang.org/ja/overviews/collections/views.html\" target=\"_blank\" rel=\"noreferrer noopener\">ビュー</a>を使いましょう。これでこの記事の役割は9割終えてしまったのですが、備忘録も兼ねて詳細のメモを記したいと思います。</p>\n\n\n\n<p>早速ですが、次のコードを見て下さい:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nList(1, 2, 3)\n  .map { x =&gt; \n    println(s&quot;$x is doubled&quot;)\n    x * 2 \n  }\n  .take(2)\n  .foreach(println)\n</pre>\n\n\n<p>上記のコードは次のように出力されます:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n1 is doubled\n2 is doubled\n3 is doubled\n2\n4\n</pre>\n\n\n<p><code>map</code>&nbsp;はコレクションの要素に対して関数を適用させます。<br>上記の例では、&nbsp;<code>Int</code>&nbsp;型の要素を2倍にした値を返しています。<br>※本来であれば&nbsp;<code>println</code>&nbsp;の様な副作用のある処理を内部に書くのは好ましく有りませんが、検証用にここでは呼び出しています。</p>\n\n\n\n<p>その後、&nbsp;<code>.take(2)</code>&nbsp;で先頭から2要素だけ取得しています。</p>\n\n\n\n<p>さて、改めてコンソールに目を向けてみると、&nbsp;<code>take(2)</code>&nbsp;が処理される前に、全件に対して最初の&nbsp;<code>map</code>&nbsp;が実行されているのが分かります。</p>\n\n\n\n<h2 id=\"何が問題だったか\"><a href=\"https://hackmd.io/3lcOVh2vTaOCYCwZbZhSVA?view#%E4%BD%95%E3%81%8C%E5%95%8F%E9%A1%8C%E3%81%A0%E3%81%A3%E3%81%9F%E3%81%8B\"></a>何が問題だったか</h2>\n\n\n\n<p>恐らく、大抵の用途では上記の仕様で困る事はほとんど無いかと思います。今回は、とあるプロジェクトでRedisクラスタを使っていた時に問題が発覚しました。</p>\n\n\n\n<p>そのプロジェクトでは、<a href=\"https://github.com/redisson/redisson\" target=\"_blank\" rel=\"noreferrer noopener\">Redisson</a>と言うフレームワークを使ってRedisクラスタとのやり取りを行っていました。</p>\n\n\n\n<p>ワークロードとしては、特定のパターンにマッチするキーのデータを取得すると言う物で、実装は次のような感じでした:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nval redisson: org.redisson.api.RedissonClient = ???\nval data: Iterable[String] = redisson\n  .getKeys                    \n  .getKeysByPattern(&quot;FOO:*&quot;) // &lt;-- Iterable[String]\n  .asScala\n  .flatMap { key =&gt;     \n    Option(\n      // 取得したキーでRedisにGETコマンドを実行. 返り値はnullableなのでOption + flatMap\n      redisson\n        .getBucket[String](\n          key,     \n          org.redisson.client.codec.StringCodec.INSTANCE\n        )\n        .get()\n    )\n  }\n  .take(30_000)\n</pre>\n\n\n<p>尚、ユースケースをもう少し詳しく説明すると、このワークロードは3分に1度だけ実行する、&nbsp;<code>FOO:*</code>&nbsp;にマッチするRedisレコードを最大で3万件取得して処理すると言う物になります。当該レコードは180秒強のTTLが設定されている為、あぶれたレコードは次回のスケジュール前に破棄されます。</p>\n\n\n\n<p>しばらく運用していると、ワークロードの処理時間が伸びて終わらなくなってしまいました。（タイムアウトを設定している為強制終了となっていました）</p>\n\n\n\n<p>コードを分析してみた所、flatMapの部分から先に進んでいない様でした。<br><code>take(30_000)</code>&nbsp;を言わばSQLのLIMIT句の様に期待して記述していたのですが、冒頭の記したとおりScalaのコレクションはデフォルトで中間コレクションを都度作成する為、ヒットした10万件超に対して&nbsp;<code>flatMap</code>&nbsp;が実行されていたのが原因だったと言う訳です。</p>\n\n\n\n<h2 id=\"Scalaの公式ドキュメントを読んでみると\"><a href=\"https://hackmd.io/3lcOVh2vTaOCYCwZbZhSVA?view#Scala%E3%81%AE%E5%85%AC%E5%BC%8F%E3%83%89%E3%82%AD%E3%83%A5%E3%83%A1%E3%83%B3%E3%83%88%E3%82%92%E8%AA%AD%E3%82%93%E3%81%A7%E3%81%BF%E3%82%8B%E3%81%A8\"></a>Scalaの公式ドキュメントを読んでみると</h2>\n\n\n\n<p><a href=\"https://docs.scala-lang.org/ja/overviews/collections/views.html\" target=\"_blank\" rel=\"noreferrer noopener\">Collections | ビュー</a>の項目を見ると、</p>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>全ての変換演算子を遅延実装している Stream を除いて、Scala のコレクションは全ての変換演算子をデフォルトで正格法で実装している。しかし、コレクションのビューにより、体系的に全てのコレクションを遅延したものに変え、また逆に戻すことができる。ビュー (view) は特殊なコレクションの一種で、何らかのコレクションに基づいているが全ての変換演算子を遅延実装している。</p></blockquote>\n\n\n\n<p>と書かれています。&nbsp;<em>正格法 (Strict)</em>&nbsp;では、コレクションの処理 (<code>map</code>,&nbsp;<code>flatMap</code>,&nbsp;<code>filter</code>等) を行う度に中間結果のコレクションが生成されると言う事を意味します。今回のケースで言うと、10万件の要素を持つコレクションに対してmapやflatMapを適用する場合は、常にこの10万件に対して処理が行われ、次の処理にデータが渡される事になります。</p>\n\n\n\n<p>そこで、ドキュメントにも記載されている通り、次のように&nbsp;<code>.view</code>&nbsp;を間に挟む事でコレクション処理を遅延させる事ができます:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nList(1, 2, 3)\n  .view\n  .map { x =&gt; \n    println(s&quot;$x is doubled&quot;)\n    x * 2 \n  }\n  .take(2)\n  .foreach(println)\n</pre>\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n1 is doubled\n2\n2 is doubled\n4\n\n</pre>\n\n\n<p>結果を見ての通り、&nbsp;<code>take(2)</code>&nbsp;で取得した2件に対してmapの関数が適用されました。その後、先程のRedissonのプロジェクトにも同様にviewを適用してみます:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nval data: Iterable[String] = redisson\n  .getKeys                    \n  .getKeysByPattern(&quot;FOO:*&quot;) // &lt;-- Iterable[String]\n  .asScala\n  .view                      // &lt;-- View[String]\n  .flatMap { key =&gt;          // このflatMapの処理は後続の .take(30_000) が実行されるまで遅延される\n    Option(\n      redisson\n        .getBucket[String](\n          key,     \n          org.redisson.client.codec.StringCodec.INSTANCE\n        )\n        .get()\n    )\n  }\n  .take(30_000)\n</pre>\n\n\n<p>コードにし示した通り、&nbsp;<code>Iterable.view</code>&nbsp;を実行するとコレクションのビューが返り、以降のコレクション処理はいくつチェーンしても、実行が実際に元のコレクションを戻すまで遅延されます。<br>この他にも&nbsp;<code>fold</code>&nbsp;や&nbsp;<code>reduce</code>,&nbsp;<code>foreach</code>&nbsp;等を実行した場合も同様に遅延されていた処理が実行されます。また、&nbsp;<code>force</code>&nbsp;を実行する事でコレクションを単に戻すだけも可能です。</p>\n\n\n\n<h2 id=\"使い分け\"><a href=\"https://hackmd.io/3lcOVh2vTaOCYCwZbZhSVA?view#%E4%BD%BF%E3%81%84%E5%88%86%E3%81%91\"></a>使い分け</h2>\n\n\n\n<p>これまたビューのドキュメントに指針が書かれています。</p>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>性能を比較すると遅延コレクションが常に正格コレクションに勝るとは限らないというものがある。コレクションのサイズが小さい場合、ビュー内でクロージャを作成し適用するためのオーバーヘッドが、中間結果のためのデータ構造を回避することによる利得を上回ってしまうことが多いのだ。</p></blockquote>\n\n\n\n<p>（中略）</p>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>ビューの使用は二つのシナリオに限るべきだ。一つは、ビューの適用を副作用を伴わない純粋関数型のコードに限ること。もしくは、明示的に全ての変更が行われる可変コレクションに適用することだ。避けたほうがいいのは、ビューと新たなコレクションを作成しつつ副作用を伴う演算を混合することだ。</p></blockquote>\n\n\n\n<p>今回のようにコレクションの数が巨大になり得る場合は使った方が良さそうです。</p>\n\n\n\n<h2 id=\"余談\"><a href=\"https://hackmd.io/3lcOVh2vTaOCYCwZbZhSVA?view#%E4%BD%99%E8%AB%87\"></a>余談</h2>\n\n\n\n<p>余談ですが筆者はScalaでSparkを扱う事が多い（Scala力自体は低い）ので、この辺の遅延処理はデフォルトで行われる物と誤解していていました。今回使っているビューは、最終的なコレクション結果が必要になるまで中間処理は全て遅延されると言う挙動が、Sparkのコレクション処理に近くて分かりやすいと感じました。</p>\n","dateObject":"2020-08-17T02:50:00.000Z","date":"August 17, 2020","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"Collection","slug":"collection"},{"name":"Redis","slug":"redis"},{"name":"Scala","slug":"scala"},{"name":"遅延処理","slug":"%e9%81%85%e5%bb%b6%e5%87%a6%e7%90%86"}],"author":{"name":"issei_m","slug":"issei"},"featured_media":{"media_details":{"sizes":{"large":{"source_url":"https://i0.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/10/Screen-Shot-2019-10-23-at-17.48.40.png?fit=1024%2C181&ssl=1","height":181,"width":1024},"medium_large":{"source_url":"https://i0.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2019/10/Screen-Shot-2019-10-23-at-17.48.40.png?fit=768%2C136&ssl=1","height":136,"width":768}}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2019/10/Screen-Shot-2019-10-23-at-17.48.40.png"},"wordpress_id":1599}},"pageContext":{"id":"c6a5d80c-0590-56be-be61-09eae343ee44","nextPath":"/2020/07/27/data-labeling-by-label-studio/","nextTitle":"Label Studio で教師データ作成","prevPath":"/2020/08/25/データベースの論理削除と物理削除/","prevTitle":"データベースの論理削除と物理削除"}}}