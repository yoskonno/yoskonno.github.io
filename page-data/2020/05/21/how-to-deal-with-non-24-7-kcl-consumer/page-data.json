{"componentChunkName":"component---src-templates-post-js","path":"/2020/05/21/how-to-deal-with-non-24-7-kcl-consumer/","result":{"data":{"wordpressPost":{"id":"9ddc65e3-7ebb-5459-8a6f-a5c2a85cd3e8","title":"24時間稼働でないKinesisストリームの運用で手こずった点","excerpt":"<p>前回に引き続き、Kinesisネタです。今回は、前回紹介したとあるコンシューマアプリケーションの運用で、タイトルにもある通り24時間稼働ではないユースケースでの運用で少しハマった点があるので書き記します。 ダウンタイムに [&hellip;]</p>\n","slug":"how-to-deal-with-non-24-7-kcl-consumer","content":"\n<p><a href=\"https://stg-engineering-wp.mobalab.net/2020/05/14/create-kinesis-consumer-using-kcl-in-scala/\" target=\"_blank\" rel=\"noreferrer noopener\">前回</a>に引き続き、Kinesisネタです。今回は、前回紹介したとあるコンシューマアプリケーションの運用で、タイトルにもある通り24時間稼働ではないユースケースでの運用で少しハマった点があるので書き記します。</p>\n\n\n\n<h2>ダウンタイムについて</h2>\n\n\n\n<p>今回のビジネスのユースケースでは、午前8時〜午後8時までのようにデータの処理は24時間する訳ではなく、ダウンタイムが設けられています。</p>\n\n\n\n<p>コンシューマを実行しているインスタンスはオートスケーリンググループにより、ダウンタイム中はTerminateされ、翌日新しくインスタンスが立てられます。</p>\n\n\n\n<h2>前提</h2>\n\n\n\n<ul><li class=\"\">コンシューマアプリケーションはKCLの1.xを使っている</li><li class=\"\">systemdによってサービス登録されている</li><li class=\"\">使用しているOSはAmazon Linux 2</li></ul>\n\n\n\n<h2>ハマった点: 最後のチェックポイントがうまく記録できない</h2>\n\n\n\n<p>今回のコンシューマアプリケーションでは、&nbsp;<code>processRecords</code>&nbsp;による定期記録 (メソッド内の全レコードを処理した後に記録) と&nbsp;<code>requestedShutdown</code>&nbsp;による最終的な記録を行っているのですが、ダウンタイム直前にプロデューサーから大量のレコードがPushされると、うまくチェックポイントを記録できなくなりました。</p>\n\n\n\n<p>原因としては、&nbsp;<code>requestShutdown</code>&nbsp;が呼ばれるのが、&nbsp;<code>processRecords</code>&nbsp;の処理が終わった後だからのようで、先述の通りダウンタイム直前に大量のレコードがPushされると、EC2からのシャットダウン時のsystemdからのSIGTERMをタイムアウト前に処理できず、結果最後の&nbsp;<code>processRecords</code>&nbsp;で処理したレコード分が丸ごと記録できないと言う事態が起きていました。</p>\n\n\n\n<h2>翌朝起動した時にその大量のレコードを再度処理する事になる</h2>\n\n\n\n<p>大量のレコードが最後のレコード処理に来ると、最後のチェックポイントが記録できずにアプリケーションが終了する為、翌朝8時に起動した際にこれらのレコードをもう一度処理する事になってしまいます。<br>レコード処理自体は冪等性をもたせる必要があるため、重複処理事態は問題がないのですが、MillisBehindLatestが増加し、本来8時から処理しなければならないレコードの同期ずれが起きる事態となっていました。<br>今回、同期ずれ10分程度は許容できるのでそこまで問題はないですが、不要な同期ずれは極力なくしたいと思い、いくつか対応策を検討しました。</p>\n\n\n\n<h2>systemdの終了タイムアウトを伸ばした (未解決)</h2>\n\n\n\n<p>デフォルトでは90秒であるタイムアウトの時間を試しに10分程度伸ばしてみました。<br>しかし、これは解決しませんでした。ログを見ると、10分待つ事なくインスタンスがTerminateになっており不思議に思っていたのですが、AWSのドキュメントに普通に書いてありました。</p>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>Amazon EC2 コンソール、コマンド行ツール、または Amazon EC2 API を使用してインスタンスを再起動する場合、インスタンスが 4 分以内に完全にシャットダウンしないと、ハードリブートが実行されます。</p><cite><a href=\"https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/ec2-instance-reboot.html\">https://docs.aws.amazon.com/ja_jp/AWSEC2/latest/UserGuide/ec2-instance-reboot.html</a></cite></blockquote>\n\n\n\n<h2>DynamoDBのデータを定期削除するようにした (解決)</h2>\n\n\n\n<p>解決策として、最終的にチェックポイント記録のバックエンドとして使っているDynamoDBのデータをダウンタイム期間中にLambdaで全部削除し、KCLワーカーの初期ポジションを <code>LATEST</code> にする事で、この問題を解決しました。これにより、最後のレコード群はチェックポイントが記録されませんが、翌朝起動時にはワーカーが初期化された後に流れてきたレコードから処理されるようになります。</p>\n\n\n\n<p>また、EC2のハードリブート問題はまだ解決していませんが、今回はダウンタイムに差し掛かっているレコードはビジネス要件的にもれなく処理する必要があると言う訳ではなかったので、今回の対応策に落ち着きました。</p>\n\n\n\n<p></p>\n","dateObject":"2020-05-21T02:00:00.000Z","date":"May 21, 2020","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"AWS","slug":"aws"},{"name":"Kinesis","slug":"kinesis"}],"author":{"name":"issei_m","slug":"issei"},"featured_media":{"media_details":{"sizes":{"large":null,"medium_large":null}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2020/05/68747470733a2f2f63646e2d696d616765732d312e6d656469756d2e636f6d2f6d61782f313630302f302a5551424b6a4566663175497358483857.png"},"wordpress_id":1490}},"pageContext":{"id":"9ddc65e3-7ebb-5459-8a6f-a5c2a85cd3e8","nextPath":"/2020/05/14/create-kinesis-consumer-using-kcl-in-scala/","nextTitle":"Scala + Kinesis Client LibraryでKinesisコンシューマーアプリケーションを作る","prevPath":"/2020/05/22/bertについて勉強したことまとめ-1-bertとは-その特徴と/","prevTitle":"BERTについて勉強したことまとめ (1) BERTとは? その特徴と解決しようとした問題、及び予備知識"}}}