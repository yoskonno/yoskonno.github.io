{"componentChunkName":"component---src-templates-post-js","path":"/2020/05/22/bertについて勉強したことまとめ-1-bertとは-その特徴と/","result":{"data":{"wordpressPost":{"id":"c034aa67-9376-51a7-8b6e-5d204acccf7e","title":"BERTについて勉強したことまとめ (1) BERTとは? その特徴と解決しようとした問題、及び予備知識","excerpt":"<p>現在、社内の機械学習を用いたプロジェクトに関わっていて、その過程で学んだBERTについて今まで勉強したことをまとめてみようと思います。 自然言語処理(以下NLP)、とくにBERT周辺の理解したことを以下何回かに分けて書い [&hellip;]</p>\n","slug":"bert%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6%e5%8b%89%e5%bc%b7%e3%81%97%e3%81%9f%e3%81%93%e3%81%a8%e3%81%be%e3%81%a8%e3%82%81-1-bert%e3%81%a8%e3%81%af-%e3%81%9d%e3%81%ae%e7%89%b9%e5%be%b4%e3%81%a8","content":"\n<p>現在、社内の機械学習を用いたプロジェクトに関わっていて、その過程で学んだBERTについて今まで勉強したことをまとめてみようと思います。</p>\n\n\n\n<p>自然言語処理(以下NLP)、とくにBERT周辺の理解したことを以下何回かに分けて書いていきます。</p>\n\n\n\n<ul><li>BERTとは? その特徴と解決しようとした問題、及び予備知識 ←この記事</li><li>BERTの構造について</li><li>BERTの学習データ、BERTの汎用性がもたらしたもの、そして新しいモデルELECTRA</li></ul>\n\n\n\n<p>機械学習については、「なにかを入力して教師データを元に損失関数計算して、パラメータを更新して精度をよくするやつ」程度の認識があるものとします。</p>\n\n\n\n<p>そもそも、既に様々な解説記事がありますが、それらは既にある程度既に詳しい人向けのものだと感じました。<br>完全な初心者向けとまではいかないものの、ある程度機械学習は知っていて、これからBERTを知るという人向けの記事を目指します。</p>\n\n\n\n<h2>BERTとは</h2>\n\n\n\n<p>BERTは2018年末頃に<a href=\"https://ai.googleblog.com/2018/11/open-sourcing-bert-state-of-art-pre.html\">googleが発表した</a>、自然言語処理における深層学習を用いた画期的なモデルです。</p>\n\n\n\n<p>BERTはBidirectional Encoder Representations from Transformersの略です。</p>\n\n\n\n<p>自然言語処理という分野において、いくつかのタスクがあります。（例：質疑応答、文章要約、翻訳、…）<br>各々のタスクを解くために、それぞれに設計されたモデルが存在していました。<br>しかし、BERTはその一つのモデルを用いて、たくさんの自然言語処理上のタスクで同時にSoTA(State of The Art: 簡単に言うとその時点でのハイスコア)を叩き出しました。</p>\n\n\n\n<p>ここから、BERTのモデルを分析したり改善したりパラメータ数を増大させたりしたりといった、BERT派生の論文が多数出現しました。被引用数は既に5000件を超えています。</p>\n\n\n\n<h2>BERTの特徴</h2>\n\n\n\n<p>BERTが好成績を発揮する要素といえるものを挙げると以下のようになります。</p>\n\n\n\n<ul><li>ファインチューニングアプローチの事前学習</li><li>Masked LMという事前学習タスクの定義</li><li>主なモデル構造はTransformerのスタック</li><li>大量な文章データによる、アノテーション不要な教師あり事前学習</li></ul>\n\n\n\n<p>特に重要なのは、Masked LMです。<br>他の特徴も結果に貢献した要素ですが、新規性のあるものではなく、NLPとして既に有名であった要素たちを利用したものです。</p>\n\n\n\n<p>ただし、上記の意味を理解するためには、予備知識がないと難しいと思われます。<br>以下ではその前提となる知識や概念を、BERTの背景を踏まえて説明していこうと思います。</p>\n\n\n\n<h2>BERTの背景を押さえる</h2>\n\n\n\n<p>もちろん<a href=\"https://arxiv.org/abs/1810.04805\">元論文</a>の冒頭あたりを見れば詳しいことは書いてあるのですが、論文の著者らによる<a href=\"https://www.reddit.com/r/MachineLearning/comments/9nfqxz/r_bert_pretraining_of_deep_bidirectional/\">redditでの投稿</a>が、今回の実験のコンセプトや経緯を知るのにちょうどよいです。</p>\n\n\n\n<p>投稿の内容を要約し、元論文も加味すると、アイデアは以下のようになります。</p>\n\n\n\n<ul><li>言語モデルの改善をしたかった<ul><li>単方向性を解消したかった</li><li>文章の関係性を学習させたかった</li></ul></li><li>従来のファインチューニングの方法は性能を発揮しきれてない（のでやってみた）</li></ul>\n\n\n\n<p>まずは、上記に出てくる言葉である</p>\n\n\n\n<ul><li>「ファインチューニング」およびその言葉の前提にある「転移学習」</li><li>「言語モデル」</li></ul>\n\n\n\n<p>について理解しないといけません。</p>\n\n\n\n<h3>予備知識 1: 転移学習</h3>\n\n\n\n<p>転移学習とは、解きたいタスクとは別のタスクを事前に学習し、その結果として得られたパラメータを用いて、解きたかったタスクを解くことです。</p>\n\n\n\n<p>転移学習において、この２つのタスクの名前を、</p>\n\n\n\n<ul><li>事前に行う方を文字通り「事前学習タスク(pre-training task)」</li><li>解きたかったタスクの方を「下流タスク(downstream task)」</li></ul>\n\n\n\n<p>といいます。</p>\n\n\n\n<p>下流タスクにパラメータを渡す方法で、転移学習は簡単に２種類に分類することができます。<br>渡されたパラメータを下流タスクの学習の際に固定するか、しないかです。<br>これらはそれぞれ、特徴量ベースのアプローチ、ファインチューニングのアプローチと呼ばれます。</p>\n\n\n\n<h4>予備知識 1.1: 特徴量ベースのアプローチ</h4>\n\n\n\n<p>事前学習で得られたパラメータを固定する場合、その事前学習をするモデルは、まるごとひとつの関数とみなせます。<br>例えば、その学習済みモデルに単語を入れたら何らかのベクトルが返ります。これを解きたかったタスクの入力として利用するとき、固定されたパラメータを持つモデルの部分は、特徴量抽出器の役割を果たしているとみなせます。これが特徴量ベースアプローチと言われる所以です。</p>\n\n\n\n<h4>予備知識 1.2: ファインチューニングのアプローチ</h4>\n\n\n\n<p>一方、ファインチューニング(fine-tuning 直訳すれば微調整)というのはパラメータを固定しない場合のことを指します。<br>固定しないということは動くわけですが、何によって動くかといえば、下流タスクの学習によってです。<br>すなわち、ファインチューニングにおいては、事前学習結果のパラメータを”初期値”として利用することを意味します。</p>\n\n\n\n<p>場合によっては、部分的に固定したりといったバリエーションがあるようですが、BERTにおいては固定するパラメータはありません。</p>\n\n\n\n<p>著者らは、とくにファインチューニングのアプローチがまだ性能を発揮しきれていないと考えたので、BERTではこちらのアプローチが使われたようです。</p>\n\n\n\n<h3>予備知識 2: 言語モデル</h3>\n\n\n\n<p>言語モデル(language model)という言葉は、私が調べた範囲でも、意味が曖昧なまま使われているように感じました。</p>\n\n\n\n<p>ひとつの明確な定義が、「（確率的）言語モデルとは、与えられる単語列に対する確率分布」というものです。<br>なんのこっちゃと思われるかもしれませんが、そこまで難しい概念ではありません。</p>\n\n\n\n<p>たとえば、以下の句点で区切られた文をご覧ください。</p>\n\n\n\n<ul><li>「昔々、あるところに、おじいさん、と、おばあさん、が、いました」</li><li>「が、いました、おじいさん、あるところに、おばあさん、昔々、と」</li></ul>\n\n\n\n<p>前者は普通の文ですが、後者はそれを並べ替えてぐちゃぐちゃにしたものです。<br>前者に対して、例えば0.9だとか、高い数字を確率として出力して、逆に後者は0に近いような低い数字を返すような関数を作れれば、それは自然言語処理において役に立つはずです。</p>\n\n\n\n<p>「単語w_1からw_mが与えられた上での、それに対する確率」を数式で表すと以下のようになります。<br><a href=\"https://gyazo.com/fa1e716b0658daceabcf319236248e7d\"></a></p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img src=\"https://i2.wp.com/i.gyazo.com/fa1e716b0658daceabcf319236248e7d.png?w=1200&#038;ssl=1\" alt=\"\" data-recalc-dims=\"1\"/></figure>\n\n\n\n<p>さて、突然ですが、上の定義とは異なる確率を考えます。<br>「1からm番目の単語が分かっている上での、m+1番目の単語の確率分布」というものです。<br>数式にすると以下になります。</p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img src=\"https://i0.wp.com/i.gyazo.com/ff1ed3db32017be4f442c95bb9071c46.png?w=1200&#038;ssl=1\" alt=\"\" data-recalc-dims=\"1\"/></figure>\n\n\n\n<p>じつは、上に示した確率とこの確率は、一方からもう一方を求めることができます。（ベイズの公式を使って変形することで簡単に求められます）</p>\n\n\n\n<p>なので、これら２つの両者を「言語モデル」と言うことがあり、これは文脈に応じて変わるので注意が必要です。</p>\n\n\n\n<p>どちらかといえば、事前にｍ個の単語が分かっている上で、次の単語を予測する、という場面のほうが多いので、後者を指すことが多いです。</p>\n\n\n\n<h4>予備知識2.1: 言語モデルの単方向性</h4>\n\n\n\n<p>さて、後者の意味での言語モデルは、1~m番目の単語から、m+1番目の単語を予測するということですが、これは対象の単語の後ろであるm+2番目以降の後ろの単語を予測に利用できていません。</p>\n\n\n\n<p>両方向の学習自体は既に<a href=\"https://allennlp.org/elmo\">ELMo</a>というモデルが発表されたりしていて、良い性能を発揮していました。<br>しかし、ELMoは特徴量ベースのアプローチです。</p>\n\n\n\n<p>BERTが改善したのはまさにこの部分であり、前と後ろ両方向を元に中央の単語を予測するタスクを定義することで、結果に大きく貢献したということです。そのタスクこそが後に紹介するMasked LMです。</p>\n\n\n\n<h2>BERTにおける事前学習</h2>\n\n\n\n<p>以上を踏まえ、言語モデルの以下の２つの問題をおさらいします。</p>\n\n\n\n<ul><li>言語モデルの改善をしたかった<ul><li>単方向性を解消したかった</li><li>文章の関係性を学習させたかった</li></ul></li></ul>\n\n\n\n<p>これを解決するために著者らが作った以下の２つの事前学習タスクを確認します。</p>\n\n\n\n<ul><li>Masked LM (Masked Language Model, MLMとも略されます)</li><li>Next Sentence Prediction(以下NSP)</li></ul>\n\n\n\n<p>特に重要になるのは前者のMasked LMです。<br>（論文内ではNSPはいくつかのタスクの結果に貢献していることはわかりますが、後の研究ではあまり重要でないことがわかりました。）</p>\n\n\n\n<p>Masked LMのタスク内容自体はいたって単純で、<br>「文章中の単語を一部<code>[MASK]</code>という文字に置き換えて、そのマスクされた単語が何だったのかを推論する」という穴埋め問題です。</p>\n\n\n\n<p>ちなみにこの穴埋め問題自体は昔から存在して<a href=\"https://en.wikipedia.org/wiki/Cloze_test\">Cloze test</a>といいます。<br>BERTは、この問題を言語モデルの学習のために用いるのが有効であると示したことと言えます。<br>(だからこそ、わざわざMasked LMという名前を新たにつけているわけです。）</p>\n\n\n\n<hr class=\"wp-block-separator\"/>\n\n\n\n<p>以上が著者らによる、言語モデルに関する問題点を解消するためのアプローチの紹介、及びそれを理解するための予備知識でした。</p>\n\n\n\n<p>次回は、上に挙げた特徴の続きであるモデル構造あたりについてです。</p>\n\n\n\n<p></p>\n","dateObject":"2020-05-22T11:26:00.000Z","date":"May 22, 2020","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"BERT","slug":"bert"},{"name":"機械学習","slug":"%e6%a9%9f%e6%a2%b0%e5%ad%a6%e7%bf%92"},{"name":"自然言語処理","slug":"%e8%87%aa%e7%84%b6%e8%a8%80%e8%aa%9e%e5%87%a6%e7%90%86"}],"author":{"name":"miyamonz","slug":"miyamoto"},"featured_media":null,"wordpress_id":1503}},"pageContext":{"id":"c034aa67-9376-51a7-8b6e-5d204acccf7e","nextPath":"/2020/05/21/how-to-deal-with-non-24-7-kcl-consumer/","nextTitle":"24時間稼働でないKinesisストリームの運用で手こずった点","prevPath":"/2020/06/01/rails-has-many-through-with-scope/","prevTitle":"Rails の has_many through で scope を使う"}}}