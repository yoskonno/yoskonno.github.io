{"componentChunkName":"component---src-templates-post-js","path":"/2020/09/17/kedro触ってみた/","result":{"data":{"wordpressPost":{"id":"7960fddf-4cac-5842-be72-4a10ab864ba7","title":"kedro触ってみた","excerpt":"<p>PyTorchで学習周りのコードを書いてたのですが、今後も検証を勧めていく上で、実験結果の記録やパラメータ変更や複数モデルの比較などをするために、何らかの学習周りのコードを扱うフレームワークを利用しようと思っていました。 [&hellip;]</p>\n","slug":"kedro%e8%a7%a6%e3%81%a3%e3%81%a6%e3%81%bf%e3%81%9f","content":"\n<p>PyTorchで学習周りのコードを書いてたのですが、今後も検証を勧めていく上で、実験結果の記録やパラメータ変更や複数モデルの比較などをするために、何らかの学習周りのコードを扱うフレームワークを利用しようと思っていました。</p>\n\n\n\n<p>PyTorchやTensorFlowなどの外側の部分について、簡単にまとめつつ、kedroを触ってみたよという記事になります。</p>\n\n\n\n<h2>機械学習のライブラリについて</h2>\n\n\n\n<p>モデルの構築にはPyTorchやTensorFlowが挙げられますが、それらより外側の物事を扱う周辺ライブラリはデファクトスタンダードが決まっていないように思います。</p>\n\n\n\n<p>参考：<a href=\"https://qiita.com/fam_taro/items/c32e0a21cec5704d9a92\">https://qiita.com/fam_taro/items/c32e0a21cec5704d9a92</a></p>\n\n\n\n<p>上記の記事で挙げられるようなものは、学習周りのコードを定めるためのフレームワークです。これらのタイプのライブラリに、ちょうどいい分類の名前が無いので、「学習周りのコードを定めるためのフレームワーク」としか言えないのが難しいところです。<br>IgniteもPyTorch Lightningも、READMEにはハイレベルのAPIであるとか、オーガナイズするラッパーですとしか書かれていません。</p>\n\n\n\n<p>よく考えてみると、Rails, Laravel, DjangoあるいはFlaskといったwebアプリケーションフレームワークという呼称も、知っている人からすればどういうものなのかは想像しやすいですが、「webアプリケーションフレームワーク」という名前はそれらの実体を指すには不明瞭であるように思えます。</p>\n\n\n\n<p>IgniteかPyTorch Lightningかをとりあえず触ってみようかとも思ったのですが、今回は</p>\n\n\n\n<ul><li>定義した学習のコードを、他のデータですぐに学習を開始できる</li><li>実験ごとにjupyter notebook書き捨てせず、後から見た人に状況を説明しやすくしたい</li></ul>\n\n\n\n<p>以上のようなことを踏まえ、パイプライン構築のためのライブラリを触ってみることにしました。<br>（あとからパイプライン内部で、上記のようなライブラリを利用することもできるはずです。）</p>\n\n\n\n<h2>パイプライン構築のためのライブラリ</h2>\n\n\n\n<p>パイプラインのためのライブラリはこちらの記事によくまとまっています。<br><a href=\"https://qiita.com/Minyus86/items/70622a1502b92ac6b29c\">PythonのPipelineパッケージ比較：Airflow, Luigi, Gokart, Metaflow, Kedro, PipelineX</a></p>\n\n\n\n<p>なお、こちらの記事の筆者はPipelineXの作者であることはご注意下さい。ただそのことを割り引いて見ても、実際私もkedroを触ってみた後に、いくつか気になるところがあったのでそれらを解決してくれるラッパーが欲しくも感じました。いずれPipelineXの方も確認してみたいと思います。</p>\n\n\n\n<p>今回は、以下のような点から、kedroを使ってみました。</p>\n\n\n\n<ul><li>拡張性が高そうである</li><li>node, pipelineという概念が単純</li><li>kedro-vizという視覚化ツールがある</li><li>スターが多くてユーザが多そう</li><li>ドキュメントが多い</li><li>ソースコードがテストを除いて１万行未満</li></ul>\n\n\n\n<p>また、最悪の場合として、コードが肥大した上でkedroをやめる場合でも、nodeとして定義した関数を結合するだけなので他のライブラリに乗り換える労力も少ないのではないかと考えました。</p>\n\n\n\n<h2>kedro</h2>\n\n\n\n<p><a href=\"https://github.com/quantumblacklabs/kedro\">https://github.com/quantumblacklabs/kedro</a></p>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>Kedro is an open-source Python framework that applies software engineering best-practice to data and machine-learning pipelines.</p></blockquote>\n\n\n\n<p><a href=\"https://kedro.readthedocs.io/en/stable/\">ドキュメント</a><br>kedroとは何なのかについては、公式ドキュメントやその他ググって見つけられる記事におまかせします。</p>\n\n\n\n<h3>既存のコードをkedroに置き換える</h3>\n\n\n\n<p>既にjuypter notebookやpythonスクリプトで定義したコードを、ちょうどよい粒度で、ドキュメントに従ってnodeとして分けていきます。</p>\n\n\n\n<p>色々と省略していますが、Pipelineを作る一例です。</p>\n\n\n\n<pre class=\"wp-block-code\"><code>from kedro.pipeline import Pipeline, node\nfrom .get_optimizers import get_optimizers\nfrom .fit import fit\n\ndef create_pipeline():\n    return Pipeline(\n        &#91;\n            node(\n                get_optimizers,\n                inputs=&#91;\"pretrained_model@load\", \"total_steps\"],\n                outputs=\"optimizers\",  # tuple of optimizer and scheduler\n            ),\n            node(\n                fit,\n                &#91;\n                    \"pretrained_model@load\",\n                    \"optimizers\",\n                    \"example_train\",\n                    \"example_valid\",\n                    \"params:epochs\",\n                ],\n                \"model\",\n            ),\n        ],\n    )</code></pre>\n\n\n\n<p>Nodeとしてまとめたい内容を関数として渡せばいいので、既存のコードを別ファイルとして書いておき、importして渡すだけです。</p>\n\n\n\n<p>Nodeという概念は、関数とほぼ同義ですが、入出力に名前をつけられるという点が便利と言えます。</p>\n\n\n\n<p>実際のコードは省略しますが、自分が作ったものをkedro-vizで図にすると以下のようになりました。</p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img src=\"https://i1.wp.com/i.gyazo.com/df3e51aef2f9e6d80ccd933183b084aa.png?w=1200&#038;ssl=1\" alt=\"\" data-recalc-dims=\"1\"/></figure>\n\n\n\n<p>青い文字と枠は私が追記したものです。</p>\n\n\n\n<p>この図だけですべてを分かってもらうのは難しいかも知れないですが、補足する図として利用するにはとても有用に思えます。直接伝えたりコードを読んで理解したりする上でこの図の有無で結構違うのではないかと思います。</p>\n\n\n\n<h2>遭遇した注意点</h2>\n\n\n\n<p>パイプラインのNodeとNodeの間で受け渡されるデータは、kedroのDataSetというクラスで扱われます。<br>特にcatalg.ymlで設定をしないとMemoryDataSetが使われ、メモリと言う名前の通り、ファイルシステム等で永続化はされません。<br>このときの受け渡し、すなわちメモリ上での挙動が、デフォルトだとdeep copyです。CSVで表現されるようなテーブル上の単なるデータならコピーで問題ないのですが、機械学習で用いられる何らかのpythonオブジェクトを受け渡す際は、当然これはコピーではまずいです。<br>MemoryDataSetはこのコピーの挙動を指定できるので、<code>assign</code>とすることで、pythonオブジェクトがコピーされずそのまま受け渡せるようになります。</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\noptimizers:\n  type: MemoryDataSet\n  copy_mode: assign\n</pre>\n\n\n<p>これ自体は<a href=\"https://kedro.readthedocs.io/en/stable/10_tools_integration/01_pyspark.html#use-memorydataset-with-copy-mode-assign-for-non-dataframe-spark-objects\">ドキュメントにも書かれているのですが</a>、PySparkとの連携に関するドキュメントの中に書かれており、この挙動に気づくのにしばらく時間がかかりました。<br>（コピーされたオブジェクトが渡されていてエラーが発生しないので、学習を回しても精度が動かず原因特定に悩まされました）</p>\n\n\n\n<h2>感じた不満点</h2>\n\n\n\n<ul><li>ドキュメントの質<br>ドキュメントは確かに多いのですが、getting startedだけを読んですぐに小規模な実行が始められるという状態ではなく、結果として隅々まで読むことになりました。（もちろん、ドキュメントが無いよりかは十分良い状態ではあります） 特に、<a href=\"https://kedro.readthedocs.io/en/stable/02_get_started/03_hello_kedro.html\">A “Hello World” example</a>からの飛躍が大きく感じます。<br>ここのパート自体は単純なのですが、次のパートから<code>kedro new</code>で作られるプロジェクトフォルダでの作業になりますが、もう少しミニマルな構成が欲しくも感じました</li><li>データのバージョニングのまとめ方<br>まだドキュメントを読んだ程度の知識ですが、kedroにはデータのバージョニング自体の機能はあるのですが、dataフォルダへの保存の仕方に違和感を覚えました。<br>バージョンごとにフォルダが分かれるのではなく、個別のデータに対してフォルダが作られ、そのしたにバージョンidで異なるデータが保存されるようになっています。これはポータビリティの観点や、途中実行のしやすさから気持ち悪く感じます。<br>しかも、この機能はDataSetクラスを継承するときに定義する形で実装されてるため、今後この挙動が変更される可能性は低いように思います。</li></ul>\n\n\n\n<h2>まとめ</h2>\n\n\n\n<p>普通に使い始めるまでに、色々とドキュメントを読み漁ったり、上記した注意点に気づかずに戸惑ったりしましたが、何もない状態よりかはマシかもしれないな、と感じることができました。<br>ただ、「１実験１notebook」という運用でゴリゴリやるのと比べて飛躍的に便利であるかというと、まだ判断ができません。<br>ただ、拡張性が高いのでプロジェクト固有の処理などを定義したり差し込み処理などが実装しやすいようにはなっているようなので、ちょっとした気に入らない部分があれば自分で拡張して解決もできそうです。</p>\n","dateObject":"2020-09-17T00:00:00.000Z","date":"September 17, 2020","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":null,"author":{"name":"miyamonz","slug":"miyamoto"},"featured_media":null,"wordpress_id":1655}},"pageContext":{"id":"7960fddf-4cac-5842-be72-4a10ab864ba7","nextPath":"/2020/09/16/bertについて勉強したことまとめ-3-自己教師学習と汎/","nextTitle":"BERTについて勉強したことまとめ (3) 自己教師学習と汎用性について","prevPath":"/2020/09/23/静的データベースと動的データベース（spark-sqlの小ネ/","prevTitle":"静的データベースと動的データベース（Spark SQLの小ネタ）"}}}