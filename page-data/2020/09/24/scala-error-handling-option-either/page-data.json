{"componentChunkName":"component---src-templates-post-js","path":"/2020/09/24/scala-error-handling-option-either/","result":{"data":{"wordpressPost":{"id":"ba1b442d-2f8b-546f-acb0-aae1359e5a76","title":"Scala の Option, Either とエラー処理","excerpt":"<p>Scala ではエラー処理に使えるクラス・仕組みが沢山ありますが、今回は Option, Either を使った方法を色々紹介します。 前提知識として、Scala の Option, Either を触ったことがあり、基 [&hellip;]</p>\n","slug":"scala-error-handling-option-either","content":"\n<p>Scala ではエラー処理に使えるクラス・仕組みが沢山ありますが、今回は Option, Either を使った方法を色々紹介します。</p>\n\n\n\n<p>前提知識として、Scala の Option, Either を触ったことがあり、基本的な Scala の文法を理解しているものとします。</p>\n\n\n\n<h2>共通で使うコード</h2>\n\n\n\n<p>本題に入る前に、コード例で共通で使うクラスなどを定義します。</p>\n\n\n\n<p>基本的な処理はこの辺を使います。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\n// ユーザー情報\nclass User {\n  def id: Int\n  def getFather: Option[User]\n  def getEmailAddress: Option[String]\n  // Error型は後の方で定義しています\n  def getEmailAddressEither: Either[Error, String]\n}\n\n// ユーザー情報を取得する（Option版）\nobject UserRepository {\n  def getUserById(id: Int): Option[User]\n}\n\n// ユーザー情報を取得する（Either版）\nobject UserRepositoryEither {\n  def getUserById(id: Int): Either[Error, User]\n}\n</pre>\n\n\n<p>エラー内容などを表す以下のようなクラスも定義します。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nobject HttpStatus {\n  val Ok = 200\n  val NotFound = 404\n  val BadRequest = 403\n  val InternalServerError = 500\n}\n\n// 独自エラーの基底クラス\ntrait Error {\n  val internalErrorCode: Int\n  val httpResponse: Int\n  def writeToLog: Unit\n}\n\n// ユーザーが存在しない場合のエラー\nobject UserNotFoundError extends Error {\n  override val internalErrorCode: Int = 1\n  override val httpResponse: Int = HttpStatus.NotFound\n  override def writeToLog: Unit = ???\n}\n\n// メアドが無い人にメールを送ろうとした場合のエラー\nobject EmailingUserWithNoEmailAddressError extends Error {\n  override val internalErrorCode: Int = 1\n  override val httpResponse: Int = HttpStatus.InternalServerError\n  override def writeToLog: Unit = ???\n}\n</pre>\n\n\n<p>独自の例外も定義しておきます。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nclass UserNotFoundException(userId: Int) extends Exception(s&quot;ユーザー $userId は存在しません&quot;)\nclass EmailingUserWithNoEmailAddressException(userId: Int)\n  extends Exception(s&quot;メールアドレスを登録していないユーザー $userId にメールを送ろうとしました&quot;)\n</pre>\n\n\n<h2>Option を使った例</h2>\n\n\n\n<h3>パターンマッチを使う</h3>\n\n\n\n<p>これはみんな知っていると思いますので簡単に流しますが、以下のような例です。<code>exampleOption1</code> の戻り値ですが、<code>Ok</code> と <code>NotFound</code> が共に <code>Int</code> なので、全体として <code>Int</code> 型となります。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nimport HttpStatus._\n\ndef exampleOption1: Int = {\n  UserRepository.getUserById(1) match {\n    case Some(user) =&gt;\n      doSomethingForUser(user)\n      Ok\n    case None =&gt;\n      NotFound\n  }\n}\n</pre>\n\n\n<p>パターンマッチを使った方法だと、以下のように複数の Option を扱う場合にネストが深くなってしまうのが難点です。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\ndef exampleOption2: Int = {\n  UserRepository.getUserById(1) match {\n    case Some(user) =&gt;\n      user.getFather match {\n        case Some(father) =&gt;\n          doSomethingForUser(father)\n          Ok\n        case None =&gt;\n          NotFound\n      }\n    case None =&gt;\n      NotFound\n  }\n}\n</pre>\n\n\n<p>次項以降で、もう少し綺麗に書く方法について考えていきます。</p>\n\n\n\n<h3>getOrElse を使う</h3>\n\n\n\n<p><code>Option</code> には <code>getOrElse</code> というメソッドがありますが、それを使うと少しネストを浅く出来ます。少しはマシですが、処理がもう少し増えてくると、やはり綺麗じゃ無いなと思ってしまいます。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\ndef exampleOption3: Int = {\n  UserRepository.getUserById(1).map { user =&gt;\n    user.getFather.map { father =&gt;\n      doSomethingForUser(father)\n      Ok\n    }.getOrElse(NotFound)\n  }.getOrElse(NotFound)\n}\n</pre>\n\n\n<p>ちなみに <code>x.getOrElse(y)</code> という形の場合、<code>x</code> が <code>None</code> だった場合のデフォルト値を <code>y</code> として渡す事が多いと思います。例えば以下のようなパターンです。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nval user: User = UserRepository.getUserById(1)\n  .getOrElse(new GuestUser)\ndoSomethingForUser(user)\n</pre>\n\n\n<p>ただ <code>getOrElse</code> の中で例外を投げるというのも、よく使うパターンです。以下のような例です。この場合も、<code>user</code> の型は <code>User</code> となります。今回は初心者向けの記事なので、なぜそうなるかの理由は省略します。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nval user: User = UserRepository.getUserById(1)\n  .getOrElse(throw new UserNotFoundException(1))\ndoSomethingForUser(user)\n</pre>\n\n\n<h3>for を使った方法</h3>\n\n\n\n<p>もう少し綺麗に書きたい場合、<code>for</code> が使えます。</p>\n\n\n\n<p class=\"has-small-font-size\">Scala の <code>for</code> は、実態は <code>withFilter</code>, <code>map</code>, <code>flatMap</code> を組み合わせたものですが、これもここでは詳しく説明しません。</p>\n\n\n\n<p>for を使った例としては以下の通りです。</p>\n\n\n\n<p>ID=1の <code>user</code> がいて、かつ、その <code>user</code> の父親がいれば、その <code>father</code> に対して処理をし <code>Ok</code> を返します。一方、<code>user</code> がいないか、その <code>user</code> の父親がいない場合には <code>NotFound</code> を返します。大分スッキリしました。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\n  def exampleOption4: Int = {\n    (for {\n      user &lt;- UserRepository.getUserById(1)\n      father &lt;- user.getFather\n    } yield {\n      doSomethingForUser(father)\n      Ok\n    }).getOrElse(NotFound)\n  }\n</pre>\n\n\n<p>ただ、以下のような処理の場合には、for を使って書き換えることができません。ユーザーが存在しない場合とメアドが登録されていない場合で処理を変えたい場合です。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\ndef exampleOption5: Int = {\n  UserRepository.getUserById(1) match {\n    case Some(user) =&gt;\n      user.getEmailAddress match {\n        case Some(emailAddress) =&gt;\n          sendEmail(emailAddress)\n          Ok\n        case None =&gt;\n          logger.error(s&quot;メールアドレスを登録していないユーザー ${user.id} にメールを送ろうとした&quot;)\n          InternalServerError\n      }\n    case None =&gt;\n      NotFound\n  }\n}\n</pre>\n\n\n<p>どうすれば良いのかは、いくつかの案を後の方で紹介します。</p>\n\n\n\n<p><code>Option</code> に関してはここまでにして、次に <code>Either</code> について書いていきます。</p>\n\n\n\n<h2>Either を使った例</h2>\n\n\n\n<h3>パターンマッチを使う</h3>\n\n\n\n<p>まずは基本的な形から紹介します。これの難点は <code>Option</code> を使った例と同様で、処理が増えるとネストが深くなる点です。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\ndef exampleEither1 = {\n  UserRepositoryEither.getUserById(1) match {\n    case Left(error) =&gt;\n      error.writeToLog\n      error.httpResponse\n    case Right(user) =&gt;\n      user.getEmailAddressEither match {\n        case Left(error) =&gt;\n          error.writeToLog\n          error.httpResponse\n        case Right(emailAddress) =&gt;\n          sendEmail(emailAddress)\n          Ok\n      }\n  }\n}\n</pre>\n\n\n<h3>for を使うとスッキリ書ける</h3>\n\n\n\n<p><code>Either</code> の場合に <code>for</code> を使うと、以下のようになります。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\ndef exampleEither2: Int = {\n  (for {\n    user &lt;- UserRepositoryEither.getUserById(1)\n    emailAddress &lt;- user.getEmailAddressEither\n  } yield {\n    sendEmail(emailAddress)\n    Ok\n  }).left.map { err =&gt;\n    err.writeToLog\n    err.httpResponse\n  }.merge\n}\n</pre>\n\n\n<p>今までより少し複雑なので、以下に解説します。</p>\n\n\n\n<p>まずは以下のブロックですが、Scala の <code>Either</code> は（2.12以降で）right-biased となっていて、<code>map</code>, <code>flatMap</code> などは値が <code>Right</code> だった場合に適用されます。つまり、以下の部分は、ユーザーが存在し、かつ、そのユーザーのメアドが登録されている場合、<code>yield</code> の中が実行され、その戻り値（ <code>Ok</code> = <code>Int</code> 型）が <code>Either</code> の <code>Right</code> 側になります。従って、全体の戻り値としては <code>Either[Error, Int]</code> となります。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\n(for {\n    user &lt;- UserRepositoryEither.getUserById(1)\n    emailAddress &lt;- user.getEmailAddressEither\n  } yield {\n    sendEmail(emailAddress)\n    Ok\n  }) // Either[Error, Int]\n</pre>\n\n\n<p>次に以下の部分ですが、<code>Either[Error, Int]</code> が <code>Left</code> だった場合にこちらの処理が実行されます。エラーのログを出力し、<code>Left</code> 側は <code>err.httpResponse</code> = <code>Int</code> 型に変換されま、<code>merge</code> の前までの部分の型は <code>Either[Int, Int]</code> となります。そして、最後の <code>merge</code> で、<code>Left</code> と <code>Right</code> が合体して、全体として <code>Int</code> 型となります。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\n  }).left.map { err =&gt;\n    err.writeToLog\n    err.httpResponse\n  }.merge\n</pre>\n\n\n<h3>Option を Either に変換する</h3>\n\n\n\n<p>上の方の <code>exampleOption5</code> は、少し読みづらいコードで、<code>for</code> 文を使う事も出来ませんでしたが、<code>Option</code> を <code>Either</code> に変換することで、すぐ前に説明した <code>exampleEither2</code> のように書くことが出来ます。</p>\n\n\n\n<p>具体的には、以下のようにかけます。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\ndef exampleEither3 = {\n  (for {\n    user &lt;- UserRepository.getUserById(1).toRight(UserNotFoundError)\n    emailAddress &lt;- user.getEmailAddress.toRight(EmailingUserWithNoEmailAddressError)\n  } yield {\n    sendEmail(emailAddress)\n    Ok\n  }).left.map { err =&gt;\n    err.writeToLog\n    err.httpResponse\n  }.merge\n}\n</pre>\n\n\n<p><code>Option</code> を <code>Either</code> に変換するには、上に書いた通り <code>toRight</code> メソッドを使います。<code>toRight</code> に渡す値は、<code>Either</code> の <code>Left</code> 側になります。</p>\n\n\n\n<h3>getOrElse を使う</h3>\n\n\n\n<p><code>Either</code> にも <code>getOrElse</code> メソッドが存在します。前述の通り、 <code>Either</code> は right-biased なので、値が <code>Left</code> だった場合に <code>getOrElse</code> の中身が使われます。</p>\n\n\n\n<p>あまり無いかもしれませんが、<code>Either</code> が <code>Left</code> だった場合に適切な例外を投げたい場合などは、以下のように書けます。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\ndef exampleEither4 = {\n  val user = UserRepositoryEither.getUserById(1).getOrElse(throw new UserNotFoundException(1))\n  val email = user.getEmailAddressEither.getOrElse(throw new EmailingUserWithNoEmailAddressException(1))\n  sendEmail(email)\n  Ok\n}\n</pre>\n\n\n<h2>まとめ</h2>\n\n\n\n<p>Scala の <code>Option</code> は強力で、Scala を使っている人であれば日常的に使っていることと思います。一方、<code>Either</code> も強力ですが、<code>Option</code> とどう使い分けたら良いのかなどが分からず、<code>Option</code> ほど使っていない人も多いと思います。</p>\n\n\n\n<p>本記事では、 <code>Option</code>, <code>Either</code> を使ったエラー処理の方法を、色んなパターンで説明してきました。</p>\n\n\n\n<ul><li><code>for</code> をうまく使う</li><li><code>Option</code> と独自の例外を使う</li><li><code>Either</code> と独自のエラークラスを使う</li></ul>\n\n\n\n<p>といった方法で、エラー処理を読みやすくできる可能性があるので、自分のコードを一度見直してみてはどうでしょうか。</p>\n\n\n\n<p>なお、Scala でエラー処理に使える仕組みとしては <code>scala.util.Try</code> などもあるので、これに関しては機会があれば別途説明します。</p>\n","dateObject":"2020-09-24T02:26:00.000Z","date":"September 24, 2020","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"Either","slug":"either"},{"name":"Option","slug":"option"},{"name":"Scala","slug":"scala"},{"name":"エラー処理","slug":"%e3%82%a8%e3%83%a9%e3%83%bc%e5%87%a6%e7%90%86"}],"author":{"name":"中の人（管理者）","slug":"engineering_8qmk0b"},"featured_media":{"media_details":{"sizes":{"large":{"source_url":"https://i0.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2020/09/error-261888_1280.jpg?fit=1024%2C650&ssl=1","height":650,"width":1024},"medium_large":{"source_url":"https://i0.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2020/09/error-261888_1280.jpg?fit=768%2C487&ssl=1","height":487,"width":768}}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2020/09/error-261888_1280.jpg"},"wordpress_id":1684}},"pageContext":{"id":"ba1b442d-2f8b-546f-acb0-aae1359e5a76","nextPath":"/2020/09/23/静的データベースと動的データベース（spark-sqlの小ネ/","nextTitle":"静的データベースと動的データベース（Spark SQLの小ネタ）","prevPath":null,"prevTitle":null}}}