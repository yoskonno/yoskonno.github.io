{"componentChunkName":"component---src-templates-post-js","path":"/2020/09/15/manage-aks-secrets-with-azure-key-vault/","result":{"data":{"wordpressPost":{"id":"b059753c-b10b-5aab-8164-b5011e52d3c4","title":"AKS上のKubernetesの秘匿情報をAzure Key Vaultで管理する方法","excerpt":"<p>最近AKSでKubernetesを管理しているのですが、SecretオブジェクトをAzure Key Vaultで管理したくなり、調べた所、Azure Key Vault Provider for Secrets Sto [&hellip;]</p>\n","slug":"manage-aks-secrets-with-azure-key-vault","content":"\n<p>最近AKSでKubernetesを管理しているのですが、Secretオブジェクトを<a rel=\"noreferrer noopener\" href=\"https://azure.microsoft.com/en-us/services/key-vault/\" target=\"_blank\">Azure Key Vault</a>で管理したくなり、調べた所、<a rel=\"noreferrer noopener\" href=\"https://github.com/Azure/secrets-store-csi-driver-provider-azure\" target=\"_blank\">Azure Key Vault Provider for Secrets Store CSI Driver</a>にたどり着き、実際にこれを使って実現できたので、メモを残しておきます。</p>\n\n\n\n<h2 id=\"Azure-Key-Vault-Provider-for-Secrets-Store-CSI-Driverについて\"><a href=\"https://hackmd.io/zfGpzMWCT2mJ1D_6NYQQIg?view#Azure-Key-Vault-Provider-for-Secrets-Store-CSI-Driver%E3%81%AB%E3%81%A4%E3%81%84%E3%81%A6\"></a>Azure Key Vault Provider for Secrets Store CSI Driverとは</h2>\n\n\n\n<p>Kubernetes SIGs管理下の<a rel=\"noreferrer noopener\" href=\"https://github.com/kubernetes-sigs/secrets-store-csi-driver\" target=\"_blank\">Secrets Store CSI Driver</a>プロジェクトのプロバイダ実装で、Key VaultとSecrets Store CSI Driverを連携させる事ができます。メンテはAzureチームが行っています:&nbsp;<a rel=\"noreferrer noopener\" href=\"https://github.com/Azure/secrets-store-csi-driver-provider-azure\" target=\"_blank\">https://github.com/Azure/secrets-store-csi-driver-provider-azure</a></p>\n\n\n\n<p>Secrets Store CSI Driverは、Kubernetesで秘匿情報を扱うのに特化したCSI Driver統合で、Azure Key Vault等の外部の秘匿情報プロバイダと連携して、KubernetesのPodにこれらの情報をファイルシステムとしてマウントする機能を持っています。CSI Driver自体は各種コンテナオーケストレータ用に抽象化された共通ストレージインターフェースとなっており、Kubernetes特有の機能ではありませんが、Kubernetesも標準でこれを実装しています。 (詳しくは<a rel=\"noreferrer noopener\" href=\"https://syucream.hatenablog.jp/entry/2018/12/04/004539\" target=\"_blank\">こちら</a>)<br>登場人物が多くて少々混乱しますが、図にすると以下のような関係になっています:</p>\n\n\n\n<div class=\"wp-block-image\"><figure class=\"aligncenter size-large\"><img src=\"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2020/09/Class-Diagram-1.png?w=1200&#038;ssl=1\" alt=\"\" class=\"wp-image-1636\" srcset=\"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2020/09/Class-Diagram-1.png?w=882&amp;ssl=1 882w, https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2020/09/Class-Diagram-1.png?resize=300%2C135&amp;ssl=1 300w, https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2020/09/Class-Diagram-1.png?resize=768%2C347&amp;ssl=1 768w\" sizes=\"(max-width: 882px) 100vw, 882px\" data-recalc-dims=\"1\" /></figure></div>\n\n\n\n<p>さて、今回はこのプロバイダを使って、AzureのService Principal権限でAzure Key Vaultに格納されているSecretsをKubernetesのPodから読み込む方法の手順を記します。</p>\n\n\n\n<h2 id=\"今回やる事\"><a href=\"https://hackmd.io/zfGpzMWCT2mJ1D_6NYQQIg?view#%E4%BB%8A%E5%9B%9E%E3%82%84%E3%82%8B%E4%BA%8B\"></a>今回やる事</h2>\n\n\n\n<p>Key Vaultに格納されている&nbsp;<code>my-secret1</code>,&nbsp;<code>my-secret2</code>&nbsp;(中身はそれぞれ <code>Secret1!!!</code>, <code>Secret2!!!</code>) をアプリケーションのPodの環境変数にそれぞれ&nbsp;<code>SECRET1</code>,&nbsp;<code>SECRET2</code>&nbsp;として定義する。</p>\n\n\n\n<p>尚、今回の検証で使うKubernetesのバージョンは1.17.9となります。また、今回オブジェクトは基本的にNamespace <code>secrets-test</code> 上にデプロイしますので、事前に作っておきます:</p>\n\n\n<pre class=\"brush: bash; title: ; notranslate\" title=\"\">\nkubectl create namespace secrets-test\n</pre>\n\n\n<h2 id=\"Service-Principalの準備\"><a href=\"https://hackmd.io/zfGpzMWCT2mJ1D_6NYQQIg?view#Service-Principal%E3%81%AE%E6%BA%96%E5%82%99\"></a>Service Principalの準備</h2>\n\n\n\n<p>Key Vaultへのアクセスを行う権限を持つService Principalを用意します:</p>\n\n\n<pre class=\"brush: bash; title: ; notranslate\" title=\"\">\naz ad sp create-for-rbac --skip-assignment\n</pre>\n\n\n<p>生成されたSPの&nbsp;<code>app-id</code>&nbsp;と&nbsp;<code>password</code>&nbsp;は後で使いますので控えておいて下さい。<br>ここではそれぞれ&nbsp;<code>app-id: 00000000-0000-0000-0000-000000000000</code>,&nbsp;<code>password: password</code>&nbsp;とします。</p>\n\n\n\n<p>次に、このSPを使ってKey VaultからSecretsを読み出せる様権限を与えます。先程のapp-idとpasswordを使って以下のコマンドを実行します:</p>\n\n\n<pre class=\"brush: bash; title: ; notranslate\" title=\"\">\naz role assignment create \\\n   --role Reader \\\n   --assignee 00000000-0000-0000-0000-000000000000 \\\n   --scope /subscriptions/aaaa1234-12ab-34cd-56ef-1234abcd4567/resourceGroups/my-group/providers/Microsoft.KeyVault/vaults/my-key-vault\n \naz keyvault set-policy \\\n   --name my-key-vault \\\n   --secret-permissions get \\\n   --spn 00000000-0000-0000-0000-000000000000\n</pre>\n\n\n<p>※ <code>az role assignment create</code> の <code>--scope</code> には事前に取得したKey VaultのIDを入れておく必要があります。以下のコマンドで調べる事ができます:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ az keyvault show -n my-keyvault --query id -o tsv\n/subscriptions/aaaa1234-12ab-34cd-56ef-1234abcd4567/resourceGroups/my-group/providers/Microsoft.KeyVault/vaults/my-key-vault\n</pre>\n\n\n<p>最後に、Secrets Store CSI DriverがKey Vaultにアクセスできるように、先程のSPのapp-idとpasswordを格納したSecretオブジェクトをKubernetesに作ります:</p>\n\n\n<pre class=\"brush: bash; title: ; notranslate\" title=\"\">\nkubectl create secret generic secrets-store-credentials \\\n  --from-literal clientid=00000000-0000-0000-0000-000000000000 \\\n  --from-literal clientsecret=password \\\n  --namespace secrets-test\n</pre>\n\n\n<p>※この情報は秘匿情報なのでマニフェストには保存しません。また、Namespaceはアプリと同じにする必要があるのでご注意下さい。</p>\n\n\n\n<h2 id=\"Azure-Key-Vault-Provider-for-Secrets-Store-CSI-Driverのインストール\"><a href=\"https://hackmd.io/zfGpzMWCT2mJ1D_6NYQQIg?view#Azure-Key-Vault-Provider-for-Secrets-Store-CSI-Driver%E3%81%AE%E3%82%A4%E3%83%B3%E3%82%B9%E3%83%88%E3%83%BC%E3%83%AB\"></a>Azure Key Vault Provider for Secrets Store CSI Driverのインストール</h2>\n\n\n\n<p>Azure Key Vault Provider (とSecrets Store CSI Driver) を事前にKubernetes上にインストールする必要があります。<br>公式ドキュメントにはHelmを使ったインストール方法が紹介されており、以下の手順でSecrets Store CSI DriverとAzure Key Vault Providerを同時にインストールできます。尚、アプリケーションと同じNamespaceにリリースする必要は無いので、今回は&nbsp;<code>default</code>&nbsp;にデプロイします:</p>\n\n\n<pre class=\"brush: bash; title: ; notranslate\" title=\"\">\nhelm repo add csi-secrets-store-provider-azure https://raw.githubusercontent.com/Azure/secrets-store-csi-driver-provider-azure/master/charts\n\nhelm install csi-secrets-store-provider-azure/csi-secrets-store-provider-azure --generate-name --namespace default \n</pre>\n\n\n<p>※Helmのインストールは<a href=\"https://github.com/helm/helm/releases\" target=\"_blank\" rel=\"noreferrer noopener\">こちら</a></p>\n\n\n\n<p>インストールが完了するとCSI DriverのDaemonSetが作られます。つまり、全てのノードに共通のPodが作られる事になります。Podの存在は次のようにして行います:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ kubectl get pods -l app=secrets-store-csi-driver --namespace default\nNAME                                                              READY   STATUS    RESTARTS   AGE\ncsi-secrets-store-provider-azure-1599821990-secrets-store-lwpkc   3/3     Running   0          44h\n\n$ kubectl get pods -l app=csi-secrets-store-provider-azure --namespace default\nNAME                                                READY   STATUS    RESTARTS   AGE\ncsi-secrets-store-provider-azure-1599821990-4vs8q   1/1     Running   0          44h\n</pre>\n\n\n<p>これでインストール完了です。</p>\n\n\n\n<h2 id=\"SecretProviderClassを作成する\"><a href=\"https://hackmd.io/zfGpzMWCT2mJ1D_6NYQQIg?view#SecretProviderClass%E3%82%92%E4%BD%9C%E6%88%90%E3%81%99%E3%82%8B\"></a>SecretProviderClassを作成する</h2>\n\n\n\n<p>SecretProviderClassは、Secrets Store CSI Driverが定義する&nbsp;<code>CustomResourceDefinition</code>&nbsp;で、このオブジェクトもクラスタにデプロイする必要があります。</p>\n\n\n\n<p>マニフェストは以下のような形になります:</p>\n\n\n<pre class=\"brush: yaml; title: ; notranslate\" title=\"\">\n# spc.yaml\n\napiVersion: secrets-store.csi.x-k8s.io/v1alpha1\nkind: SecretProviderClass\nmetadata:\n  name: my-spc\nspec:\n  provider: azure\n  parameters:\n    keyvaultName: my-key-vault\n    tenantId: aaaaaaaa-12ab-34cd-56ef-bbbbbbbbbbbb # Key VaultのTenant ID。Azure Portal上ではDirectory IDと呼ばれている\n    objects: |\n      array:\n        - |\n          objectType: secret\n          objectName: my-secret1 # Key Vaultに格納されているsecretの名前\n          objectAlias: secret1   # Secrets storageにマウントする際のファイル名。省略可能\n        - |\n          objectType: secret\n          objectName: my-secret2\n          objectAlias: secret2\n  secretObjects:\n    - data:\n        - key: SECRET1 # Kubernetes SecretsのKey名。今回は環境変数として使うので変数名にしている\n          objectName: secret1 # ↑で指定したsecretのobjectNameまたはobjectAlias\n        - key: SECRET2\n          objectName: secret2\n      secretName: my-secrets # 同期させたいKubernetesのSecret名\n      type: Opaque\n</pre>\n\n\n<p>これを適用します。尚、SecretProviderClassはアプリケーションと同じNamespaceに入れる必要があるのでご注意下さい:</p>\n\n\n<pre class=\"brush: bash; title: ; notranslate\" title=\"\">\nkubectl apply -f spc.yaml --namespace secrets-test\n</pre>\n\n\n<p>ちなみに、Key Vaultを取得する際の設定はもっと細かく指定する事ができます。 (例えばバージョン指定等) 詳しくは<a rel=\"noreferrer noopener\" href=\"https://github.com/Azure/secrets-store-csi-driver-provider-azure#using-the-azure-key-vault-provider\" target=\"_blank\">公式ドキュメント</a>をご覧下さい。</p>\n\n\n\n<h2 id=\"アプリケーションのPodで使ってみる\"><a href=\"https://hackmd.io/zfGpzMWCT2mJ1D_6NYQQIg?view#%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AEPod%E3%81%A7%E4%BD%BF%E3%81%A3%E3%81%A6%E3%81%BF%E3%82%8B\"></a>アプリケーションのPodで使ってみる</h2>\n\n\n\n<p>それでは先程作ったSecretProviderClassを使ってKey VaultのSecretをPodの環境変数に埋め込んでみましょう。マニフェストは次のような感じです:</p>\n\n\n<pre class=\"brush: yaml; title: ; notranslate\" title=\"\">\n# pod.yaml\n\nkind: Pod\napiVersion: v1\nmetadata:\n  name: my-test-pod-with-secrets\nspec:\n  containers:\n    - image: alpine\n      name: alpine\n      command: ['tail']\n      args: ['-f', '/dev/null']\n      envFrom:\n        - secretRef:\n            name: my-secrets\n      # 今回は環境変数に埋め込みたいので、ファイルシステムへのマウント機能は不要だが、Kubernetes Secretsへの同期は\n      # サブ機能であり、ボリュームマウント自体がSecrets Store for CSI Driverの本分なのでこの設定は必須である\n      volumeMounts:\n        - name: secrets-store-inline\n          mountPath: /mnt/secrets-store\n          readOnly: true\n  volumes:\n    - name: secrets-store-inline\n      csi:\n        driver: secrets-store.csi.k8s.io\n        readOnly: true\n        volumeAttributes:\n          secretProviderClass: my-spc # さっき作ったSecretProviderClass名\n        nodePublishSecretRef:\n          name: secrets-store-credentials # さっき作ったKubernetes Secret名\n</pre>\n\n\n<p>デプロイします:</p>\n\n\n<pre class=\"brush: bash; title: ; notranslate\" title=\"\">\nkubectl apply -f pod.yaml --namespace secrets-test\n</pre>\n\n\n<p>Podの存在を確認します:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n$ kubectl get pods --namespace secrets-test\nNAME                       READY   STATUS    RESTARTS   AGE\nmy-test-pod-with-secrets   1/1     Running   0          12m\n</pre>\n\n\n<p>上記の通りデプロイが確認できたら、&nbsp;<code>exec</code>&nbsp;でコンテナの中に入ってみましょう:</p>\n\n\n<pre class=\"brush: bash; title: ; notranslate\" title=\"\">\nkubectl exec my-test-pod-with-secrets -it --namespace secrets-test -- sh\n</pre>\n\n\n<p>入ったら、&nbsp;<code>env</code>&nbsp;で中身を見てみます:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n# env\n(略)\nSECRET1=Secret1!!!\nSECRET2=Secret2!!!\n</pre>\n\n\n<p>無事環境変数にセットされました。本来の機能であるボリュームの方も覗いて見ましょう:</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n# ls -l /mnt/secrets-store/\ntotal 8\n-rw-r--r--    1 root     root            10 Sep 14 03:17 secret1\n-rw-r--r--    1 root     root            10 Sep 14 03:17 secret2\n\n# cat /mnt/secrets-store/secret1\nSecret1!!!\n# cat /mnt/secrets-store/secret2\nSecret2!!!\n</pre>\n\n\n<p>しっかりマウントされていますね。無事に実験は成功です。<br>ちなみに、このPodが削除されると同期先のSecret (今回は&nbsp;<code>my-secrets</code>) も削除されます。</p>\n\n\n\n<p>最後に、検証が終わったので後片付けをしておきます:</p>\n\n\n<pre class=\"brush: bash; title: ; notranslate\" title=\"\">\nkubectl delete namespace secrets-test\n</pre>\n\n\n<h2 id=\"主観的な注意点とか感想\"><a href=\"https://hackmd.io/zfGpzMWCT2mJ1D_6NYQQIg?view#%E4%B8%BB%E8%A6%B3%E7%9A%84%E3%81%AA%E6%B3%A8%E6%84%8F%E7%82%B9%E3%81%A8%E3%81%8B%E6%84%9F%E6%83%B3\"></a>主観的な注意点とか感想</h2>\n\n\n\n<h3 id=\"1-エラーがそこそこ分かりづらい\"><a href=\"https://hackmd.io/zfGpzMWCT2mJ1D_6NYQQIg?view#1-%E3%82%A8%E3%83%A9%E3%83%BC%E3%81%8C%E3%81%9D%E3%81%93%E3%81%9D%E3%81%93%E5%88%86%E3%81%8B%E3%82%8A%E3%81%A5%E3%82%89%E3%81%84\"></a>1. エラーがそこそこ分かりづらい</h3>\n\n\n\n<p>設定に誤りがあるとPodが正しく開始されないのですが、登場人物が多い上に記述ミスや、Namespaceの配置ミス等があって一発で動かなかったりします。また、Azure Key VaultのSecretが無い時等以外では、エラーの内容を把握しづらいのも難点です。 (自分が管理するPodじゃなくてCSI Driver側のログを見たりしないといけない)</p>\n\n\n\n<p>動かない場合はログを確認したり、設定に誤りが無いか今一度確認してみて下さい。</p>\n\n\n\n<h3 id=\"2-Key-Vaultへの更新はKubernetesのSecretには自動適用されない\"><a href=\"https://hackmd.io/zfGpzMWCT2mJ1D_6NYQQIg?view#2-Key-Vault%E3%81%B8%E3%81%AE%E6%9B%B4%E6%96%B0%E3%81%AFKubernetes%E3%81%AESecret%E3%81%AB%E3%81%AF%E8%87%AA%E5%8B%95%E9%81%A9%E7%94%A8%E3%81%95%E3%82%8C%E3%81%AA%E3%81%84\"></a>2. Key Vaultへの更新はKubernetesのSecretには自動適用されない</h3>\n\n\n\n<p>Kubernetes Secrets側に同期する場合、Key Vaultや、SecretProviderClassオブジェクトへの変更は自動的にSecretには適用されません。<br>また、このSecret自体のライフサイクルがCSI Driver、すなわちPodのボリュームと同様となっていますので、Podを削除する事によってSecretが削除されるまでは内容が変わる事も無いので、Key VaultのSecretの値を更新したい時等は以下の手順を踏む必要があります:</p>\n\n\n\n<ul><li>Key VaultでSecretの内容を更新する (追加、更新等)</li><li>必要に応じて (値を追加した時等) SecretProviderClassオブジェクトを更新する</li><li>Podを削除し、再度デプロイする (実際の運用ではDeploymentやReplicaSet経由で行われる)</li></ul>\n\n\n\n<h3 id=\"3-まだ開発中なので注意\"><a href=\"https://hackmd.io/zfGpzMWCT2mJ1D_6NYQQIg?view#3-%E3%81%BE%E3%81%A0%E9%96%8B%E7%99%BA%E4%B8%AD%E3%81%AA%E3%81%AE%E3%81%A7%E6%B3%A8%E6%84%8F\"></a>3. まだ開発中である事を認識する必要がある</h3>\n\n\n\n<p>KubernetesとしてはCSI Driverは既にStableとなっていますが、Secrets Store for CSI Driver側のAPIのバージョンが&nbsp;<code>v1alpha1</code>&nbsp;ですので今後大きな仕様の変更は有りえます。現時点でも機能としては十分使えそうですが、こまめに公式の動向を追う必要がありそうです。</p>\n","dateObject":"2020-09-15T01:00:00.000Z","date":"September 15, 2020","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"Azure","slug":"azure"},{"name":"CSI Driver","slug":"csi-driver"},{"name":"k8s","slug":"k8s"},{"name":"Key Vault","slug":"key-vault"},{"name":"Kubernetes","slug":"kubernetes"},{"name":"Secrets Store CSI Driver","slug":"secrets-store-csi-driver"}],"author":{"name":"issei_m","slug":"issei"},"featured_media":{"media_details":{"sizes":{"large":null,"medium_large":null}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2020/09/Untitled-2.png"},"wordpress_id":1625}},"pageContext":{"id":"b059753c-b10b-5aab-8164-b5011e52d3c4","nextPath":"/2020/08/25/underscores-in-docker-compose-service-name-makes-hostname-invalid/","nextTitle":"docker-compose.ymlのサービス名にアンダースコアを使うと正しいインターネットホスト名ではなくなる","prevPath":"/2020/09/16/bertについて勉強したことまとめ-3-自己教師学習と汎/","prevTitle":"BERTについて勉強したことまとめ (3) 自己教師学習と汎用性について"}}}