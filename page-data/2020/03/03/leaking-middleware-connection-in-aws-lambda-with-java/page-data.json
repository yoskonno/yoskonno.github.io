{"componentChunkName":"component---src-templates-post-js","path":"/2020/03/03/leaking-middleware-connection-in-aws-lambda-with-java/","result":{"data":{"wordpressPost":{"id":"a4f6c356-2ec6-5e13-8f2e-aaa7fabe838f","title":"AWS LambdaのJavaランタイムでミドルウェアのコネクションのリークでハマった件","excerpt":"<p>今回はAWS LambdaでJava 8ランタイムを使った際に、Redis等のミドルウェアとのコネクションの管理関連でハマった点を備忘録として残しておきます。AWS Lambdaを使う上では抑えておくべき点である基本的な [&hellip;]</p>\n","slug":"leaking-middleware-connection-in-aws-lambda-with-java","content":"\n<p>今回はAWS LambdaでJava 8ランタイムを使った際に、Redis等のミドルウェアとのコネクションの管理関連でハマった点を備忘録として残しておきます。<br>AWS Lambdaを使う上では抑えておくべき点である基本的な内容の為、初心者向けの内容となっています。</p>\n\n\n\n<h2 id=\"アプリケーションの概要と発生していた現象\"><a href=\"https://hackmd.io/Sq6chLF6SZ2o4bdgcPwEJA?view#%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E6%A6%82%E8%A6%81%E3%81%A8%E7%99%BA%E7%94%9F%E3%81%97%E3%81%A6%E3%81%84%E3%81%9F%E7%8F%BE%E8%B1%A1\"></a>アプリケーションの概要と発生していた現象</h2>\n\n\n\n<ul><li class=\"\">言語はScala、ハンドラのタイプは&nbsp;<code>com.amazonaws.services.lambda.runtime.RequestStreamHandler</code></li><li class=\"\">実行経路はCloudWatch Eventsで、3分間に一度実行</li><li class=\"\">ミドルウェアとしてRDS (※), ElastiCache (Redisクラスタ), Amazon MQを使用<ul><li class=\"\">それぞれハンドラの中でコネクションを確立</li><li class=\"\">RDSには&nbsp;<code>org.scalikejdbc</code>, Redisには&nbsp;<code>org.redisson</code>, Amazon MQには&nbsp;<code>org.apache.activemq</code>&nbsp;をそれぞれクライアントモジュールとして使用しています</li></ul></li></ul>\n\n\n\n<p>現象:</p>\n\n\n\n<ul><li>3分に1回実行はされているが、何回かに1度、アプリケーションが正常に終了しない</li><li>正常に終了しない場合は、Lambdaからの終了ログ、およびレポートログすら表示されない<ul><li><code>REPORT RequestId: XXX Duration: ??? ms Billed Duration: ??? ms Memory Size: ??? MB Max Memory Used: ??? MB Init Duration: ??? ms</code> って奴</li></ul></li><li>アプリの随所でログを流してみると、RDS、Amazon MQとのコネクションは確立できているが、Redisのコネクションが失敗時には流れていない</li></ul>\n\n\n\n<p>と言う訳でRedisへの接続の部分に問題がありそうと言う事はわかりました。</p>\n\n\n\n<hr class=\"wp-block-separator\"/>\n\n\n\n<p>※昔はRDSのコネクションをLambda内で開くのはBad Practiceとされていましたが、今回は3分に1度しか起動されない事が保証されている為問題ないです。また、最近では<a href=\"https://aws.amazon.com/jp/blogs/compute/using-amazon-rds-proxy-with-aws-lambda/\" target=\"_blank\" rel=\"noreferrer noopener\">Amazon RDS Proxy</a>の登場で不特定多数がLambdaを起動する様なワークロードでも問題が無くなるそうです。</p>\n\n\n\n<h2 id=\"アプリケーションの構成詳細\"><a href=\"https://hackmd.io/Sq6chLF6SZ2o4bdgcPwEJA?view#%E3%82%A2%E3%83%97%E3%83%AA%E3%82%B1%E3%83%BC%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E6%A7%8B%E6%88%90%E8%A9%B3%E7%B4%B0\"></a>アプリケーションの構成詳細</h2>\n\n\n\n<p>アプリケーションは、次のようにハンドラメソッド内で各種ミドルウェアに接続し、処理を実行する、と言う物でした。</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nimport java.io.{InputStream, OutputStream}\nimport java.sql.DriverManager\n\nimport com.amazonaws.services.lambda.runtime.{Context, RequestStreamHandler}\nimport com.mysql.cj.jdbc.Driver\nimport grizzled.slf4j.Logging\nimport javax.jms.{DeliveryMode, Session}\nimport org.apache.activemq.ActiveMQConnectionFactory\nimport org.apache.activemq.pool.PooledConnectionFactory\nimport org.redisson.Redisson\nimport org.redisson.api.RedissonClient\nimport org.redisson.config.{Config, ReadMode}\nimport scalikejdbc.{ConnectionPool, DB, DBSession, GlobalSettings, LoggingSQLAndTimeSettings}\n\nclass App extends RequestStreamHandler with Logging {\n\n  override def handleRequest(input: InputStream, output: OutputStream, context: Context): Unit = {\n    logger.info(&quot;Execution start&quot;)\n    \n    val redissonClient = _redissonClient()\n    val rdbConnection = _rdbConnection()\n    val mqProducer = _mqProducer()\n    \n    // ...\n    \n    logger.info(&quot;Execution completed&quot;)\n  }\n\n  private def _redissonClient(): RedissonClient = {\n    // prepare the Redis connection\n    val config = new Config()\n    config\n      .useClusterServers()\n      .setReadMode(ReadMode.MASTER_SLAVE)\n      .addNodeAddress(&quot;redis://xxx&quot;)\n\n    Redisson.create(config)\n  }\n\n  // RDBやAmazonMQ用のクライアントも同様にprivate defで定義していた\n\n}\n</pre>\n\n\n<h2 id=\"原因はコネクションのリークによる枯渇\"><a href=\"https://hackmd.io/Sq6chLF6SZ2o4bdgcPwEJA?view#%E5%8E%9F%E5%9B%A0%E3%81%AF%E3%82%B3%E3%83%8D%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%81%AE%E3%83%AA%E3%83%BC%E3%82%AF%E3%81%AB%E3%82%88%E3%82%8B%E6%9E%AF%E6%B8%87\"></a>原因はコネクションのリークによる枯渇</h2>\n\n\n\n<p>勘の良い方ならお気づきかもしれませんが、Redissonを始めとする各種ミドルウェアのコネクションがハンドラ内で接続を確立し、処理を実行後に閉じていないのが原因でした。<br>この状態ですと、3分に一度アプリケーションが起動するたびに新しいコネクションが貼られ、その内に最大コネクション数に達してしまい、後のアプリケーションの実行が止まってしまっていたのです。</p>\n\n\n\n<p>Lambdaが実行用のインスタンスを再利用する事はFAQにも書かれていますが、</p>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>Q: AWS Lambda は関数インスタンスを再利用しますか?<br>パフォーマンス向上のため、AWS Lambda は新しく関数のインスタンスを作成するのではなく、関数のインスタンスを保持してその後のリクエストに対応することがあります。</p><p><a href=\"https://aws.amazon.com/jp/lambda/faqs/\" target=\"_blank\" rel=\"noreferrer noopener\">https://aws.amazon.com/jp/lambda/faqs/</a></p></blockquote>\n\n\n\n<p>Javaランタイムの場合、実行インスタンスだけでなく、Javaのプロセスその物（＋ハンドラを実装しているJavaのクラスインスタンスさえも）も再利用されるみたいなのです。</p>\n\n\n\n<p>試しに、コンストラクタに次のようなログを吐き出してみます:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nclass App extends RequestStreamHandler with Logging {\n\n  logger.info(s&quot;Instantiate handler with PID: ${hashCode().toString}&quot;)\n  \n  // ...\n  \n}\n</pre>\n\n\n<p>CloudWatch Logs上で確認してみると、次のように最初の1回だけ仕込んだログが吐き出され、以降はログが見られない事がわかります。</p>\n\n\n<pre class=\"brush: plain; title: ; notranslate\" title=\"\">\n[main] INFO App - Instantiate handler: 211024580\nSTART RequestId: xxx Version: $LATEST\n[main] INFO App - Execution start\n...\n[main] INFO App - Execution completed\nEND RequestId: xxx\nREPORT RequestId: xxx Duration: ??? ms Billed Duration: ??? ms Memory Size: ??? MB Max Memory Used: ??? MB Init Duration: ??? ms \nSTART RequestId: yyy Version: $LATEST\n[main] INFO App - Execution start\n...\n[main] INFO App - Execution completed\nEND RequestId: yyy\nREPORT RequestId: yyy Duration: ??? ms Billed Duration: ??? ms Memory Size: ??? MB Max Memory Used: ??? MB Init Duration: ??? ms \n...\n</pre>\n\n\n<p>※Lambdaの&nbsp;<code>START</code>&nbsp;ログよりも先に展開されるのは興味深いですね。</p>\n\n\n\n<p>その後もログを追いかけてみると、大体2時間くらいは同じインスタンスが使われているようでした。</p>\n\n\n\n<h2 id=\"コネクションを使い回すよう変更して解決\"><a href=\"https://hackmd.io/Sq6chLF6SZ2o4bdgcPwEJA?view#%E3%82%B3%E3%83%8D%E3%82%AF%E3%82%B7%E3%83%A7%E3%83%B3%E3%82%92%E4%BD%BF%E3%81%84%E5%9B%9E%E3%81%99%E3%82%88%E3%81%86%E5%A4%89%E6%9B%B4%E3%81%97%E3%81%A6%E8%A7%A3%E6%B1%BA\"></a>コネクションを使い回すよう変更して解決</h2>\n\n\n\n<p>元々は、Javaのプロセスそのものは毎回初期化されるだろうと言う先入観で、コネクションのクローズ処理を明示していなかったのですが、クラスインスタンスが再利用されるのであれば、コネクションの管理をクラスのメンバ変数で管理すれば良さそうです。<br>最終的には次のように、<code>private lazy val</code>&nbsp;なメンバ変数で管理する事にしました:</p>\n\n\n<pre class=\"brush: scala; title: ; notranslate\" title=\"\">\nclass App extends RequestStreamHandler with Logging {\n\n  override def handleRequest(input: InputStream, output: OutputStream, context: Context): Unit = {\n    logger.info(&quot;Execution start&quot;)\n    \n    // redissonClient変数などが使われる...\n    \n    logger.info(&quot;Execution completed&quot;)\n  }\n\n  private lazy val redissonClient: RedissonClient = {\n    // prepare the Redis connection\n    val config = new Config()\n    config\n      .useClusterServers()\n      .setReadMode(ReadMode.MASTER_SLAVE)\n      .addNodeAddress(&quot;redis://xxx&quot;)\n\n    Redisson.create(config)\n  }\n\n  // RDBやAmazonMQ用のクライアントも同様にprivate lazy defで定義\n\n}\n</pre>\n\n\n<p>因みにLambda内でのTCPコネクションの維持については、クラスメソッドさんの記事が詳しいです:</p>\n\n\n\n<blockquote class=\"wp-block-quote\"><p>Lambda実行環境はフリーズしていると言いながら、実はTCPのKeepAliveパケットは送ってくれているようです。また、Lambda実行環境が破棄されるタイミングでも、マナー悪くブツ切りしている訳ではなくちゃんとFIN/ACKを送信してくれるようです。</p><p><a href=\"https://dev.classmethod.jp/cloud/aws/lambda-tcp-keepalive/\" target=\"_blank\" rel=\"noreferrer noopener\">https://dev.classmethod.jp/cloud/aws/lambda-tcp-keepalive/</a></p></blockquote>\n\n\n\n<p>現在このアプリケーションはまだ試験中なのですが、今の所は動作しているようなのでこのまま様子見をし、また何かあれば続報を書ければと思います。</p>\n\n\n\n<h2 id=\"まとめ\"><a href=\"https://hackmd.io/Sq6chLF6SZ2o4bdgcPwEJA?view#%E3%81%BE%E3%81%A8%E3%82%81\"></a>まとめ</h2>\n\n\n\n<ul><li class=\"\">Lambdaは実行インスタンスだけでなく、リクエストハンドラのJavaクラスインスタンスも再利用する</li><li class=\"\">故にハンドラメソッド内でコネクションを開いた場合は、閉じるなりしないとコネクションのリークが発生する可能性がある</li><li class=\"\">LambdaのTCPコネクションは維持されるので、クラスインスタンス初期化時にコネクションを確立するのが良い</li></ul>\n","dateObject":"2020-03-03T03:00:00.000Z","date":"March 03, 2020","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"AWS","slug":"aws"},{"name":"java","slug":"java"},{"name":"Lambda","slug":"lambda"},{"name":"Scala","slug":"scala"}],"author":{"name":"issei_m","slug":"issei"},"featured_media":{"media_details":{"sizes":{"large":null,"medium_large":{"source_url":"https://i0.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2018/05/e307a1f39537bf408a805bf49921fe19-png.png?fit=768%2C768&ssl=1","height":768,"width":768}}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2018/05/e307a1f39537bf408a805bf49921fe19-png.png"},"wordpress_id":1364}},"pageContext":{"id":"a4f6c356-2ec6-5e13-8f2e-aaa7fabe838f","nextPath":"/2020/02/26/provision-elastic-beanstalk-environment-by-terraform/","nextTitle":"Elastic Beanstalk 環境を Terraform で構築する","prevPath":"/2020/03/11/export-github-repositories/","prevTitle":"GitHub レポジトリをエクスポートする"}}}