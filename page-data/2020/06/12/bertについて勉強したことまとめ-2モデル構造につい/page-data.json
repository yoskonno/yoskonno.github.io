{"componentChunkName":"component---src-templates-post-js","path":"/2020/06/12/bertについて勉強したことまとめ-2モデル構造につい/","result":{"data":{"wordpressPost":{"id":"cc3686ef-da59-5a71-b9db-4499cf9f90e6","title":"BERTについて勉強したことまとめ (2)モデル構造について","excerpt":"<p>前回は特徴と予備知識を確認しました。今回はBERTの構造についてです。 BERTのモデルの構造 BERTのモデル構造の主な部分は、TransformerのEncoderを複数重ねただけです。それに合わせて、その上下にどの [&hellip;]</p>\n","slug":"bert%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6%e5%8b%89%e5%bc%b7%e3%81%97%e3%81%9f%e3%81%93%e3%81%a8%e3%81%be%e3%81%a8%e3%82%81-2%e3%83%a2%e3%83%87%e3%83%ab%e6%a7%8b%e9%80%a0%e3%81%ab%e3%81%a4%e3%81%84","content":"\n<p><a href=\"https://stg-engineering-wp.mobalab.net/2020/05/22/bert%e3%81%ab%e3%81%a4%e3%81%84%e3%81%a6%e5%8b%89%e5%bc%b7%e3%81%97%e3%81%9f%e3%81%93%e3%81%a8%e3%81%be%e3%81%a8%e3%82%81-1-bert%e3%81%a8%e3%81%af-%e3%81%9d%e3%81%ae%e7%89%b9%e5%be%b4%e3%81%a8/\">前回</a>は特徴と予備知識を確認しました。<br>今回はBERTの構造についてです。</p>\n\n\n\n<h2>BERTのモデルの構造</h2>\n\n\n\n<p>BERTのモデル構造の主な部分は、TransformerのEncoderを複数重ねただけです。<br>それに合わせて、その上下にどのような層がつくのかを把握すると良いと思います。</p>\n\n\n\n<p>Transformer Encoderの中身や入出力の詳細を棚に上げれば、BERTは結構単純な構造です。<br>以下では、BERTを使う人向けに知っておくと良さそうなレベルで説明します。</p>\n\n\n\n<h3>Transformer Encoder</h3>\n\n\n\n<p>基本はTransformerのEncoder部分を複数重ねただけです。</p>\n\n\n\n<p>Transformer自体は、BERTから約１年前に登場した、NLPにおいてとても注目されているモデルです。<br>（先にBERTを知った入門者にとっては、また新しい概念が、…と大変な気持ちになりますが…）</p>\n\n\n\n<p>このTransformerについては参考になる記事が多数ありますので、そちらをご覧ください。</p>\n\n\n\n<ul><li><a href=\"https://arxiv.org/abs/1706.03762\">Attention Is All You Need</a> Transformerの構造を提唱した元論文<br></li><li><a href=\"http://nlp.seas.harvard.edu/2018/04/03/attention.html\">The Annotated Transformer</a> 元論文を注釈や図を加えて解説したもの。コードを見たほうが理解しやすい人に良さそうですが、初学者には難しい？</li><li><a href=\"http://jalammar.github.io/illustrated-transformer/\">The Illustrated Transformer</a>|モデルの構造やAttentionについて図を交えて解説したもの。</li><li><a href=\"https://glassboxmedicine.com/2019/08/15/the-transformer-attention-is-all-you-need/\">The Transformer: Attention Is All You Need</a> こちらもモデル構造の解説ですが、Illustrated Transformer以上、Annotated Transformer未満な詳細度です。</li><li><a href=\"http://deeplearning.hatenablog.com/entry/transformer\">論文解説 Attention Is All You Need (Transformer)</a> 日本語での論文解説<br></li><li><a href=\"https://qiita.com/halhorn/items/c91497522be27bde17ce\">作って理解する Transformer / Attention</a> tensorflowでTransformerを作る記事</li></ul>\n\n\n\n<p>私自身も、全ての記事に目を通して完全に理解しているわけではありません。ただ、BERTはこのTransformerという構造のEncoder部分を利用しているだけということを抑えておきましょう。<br>そしてそのEncoder部分は、入力と出力は配列であり同じ長さになります。<br>図にすると以下のようになります。</p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img src=\"https://i2.wp.com/i.gyazo.com/547d078f0fb7b8140a7567fcd0eb1cb8.png?w=1200&#038;ssl=1\" alt=\"\" data-recalc-dims=\"1\"/></figure>\n\n\n\n<p>このモデルに文章を入力するのですが、文章はトークンという単位で分割して、トークン列として入力されます。<br>そしてEncoderは、このトークン列の長さはそのままに、個別のトークンをベクトルに変換します。</p>\n\n\n\n<p>Transformer自体はEncoderとDecoderの組み合わせですが、BERTが利用してるのはEncoderの部分だけです。<br>transformer encoder自体の内側の詳細を省いてしまえば、とても単純な構造をしていることが理解できると思います。</p>\n\n\n\n<p>BERTの論文中でも、transformerについては詳しく説明はされておりません。<br>つまりモデル構造については、BERT特有の特別な工夫があるわけではありません。</p>\n\n\n\n<p>BERTに限らず、Transformerを利用したモデルが現在のNLPにおいて多く登場しています。</p>\n\n\n\n<p>注意点は、ネット上の記事を見るとよく「Transformer」と書かれていますが、これは「TransformerのEncoderの部分」の省略である場合が多いです。</p>\n\n\n\n<p>BERT及びTransformerの、個別の層やベクトルのサイズまで把握したい方は以下の記事がおすすめです</p>\n\n\n\n<ul><li><a href=\"https://www.ogis-ri.co.jp/otc/hiroba/technical/similar-document-search/part3.html\">はじめての自然言語処理 第3回 BERT を用いた自然言語処理における転移学習</a>　3.1節の構造の図が分かりやすいです。</li><li><a href=\"https://qiita.com/FuwaraMiyasaki/items/239f3528053889847825\">Transformerのデータの流れを追ってみる</a></li></ul>\n\n\n\n<h3>Transformer encoderの後ろ(pooler layer)</h3>\n\n\n\n<p>これは、学習するタスクによって変わります。<br>文章のトークン列の位置を利用するものは、その対応するベクトルを後の別のレイヤーに渡します。</p>\n\n\n\n<p>注意点ですが、分類問題のために特別に文頭に<code>[CLS]</code>というトークンをつけて学習します。<br>分類問題を解く場合には、対応する先頭のベクトルを、分類問題を解くためのレイヤーに渡します。</p>\n\n\n\n<p>分類タスクの場合<br><a href=\"https://gyazo.com/d083184c73025717450d262836473f3c\"></a></p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img src=\"https://i1.wp.com/i.gyazo.com/d083184c73025717450d262836473f3c.png?w=1200&#038;ssl=1\" alt=\"\" data-recalc-dims=\"1\"/></figure>\n\n\n\n<p>質問から解答を得るタスクの場合(Question Answering Task: SQuAD 1.1)<br><a href=\"https://gyazo.com/a1f3855181d4e3e621cc340c15b4f768\"></a></p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img src=\"https://i2.wp.com/i.gyazo.com/a1f3855181d4e3e621cc340c15b4f768.png?w=1200&#038;ssl=1\" alt=\"\" data-recalc-dims=\"1\"/></figure>\n\n\n\n<p>画像は元論文より引用</p>\n\n\n\n<p>Transformer Encoderの後ろにくるレイヤーのことを、BERTの実装されたリポジトリではpooler layerと呼ばれています。<br>(これが、機械学習の用語であるのか、英語の一般名詞なのかは私には分かりませんでした。検索した範囲で確信が得られなかったので、英語の一般名詞のように思えます)</p>\n\n\n\n<p>事前学習での２つのタスクや、ファインチューニングのときに、そのタスクに応じてpooler layerが切り替えられます。すなわち、ここのレイヤーは転移学習として利用されません。</p>\n\n\n\n<h3>Transformer encoderの前、入力部分</h3>\n\n\n\n<h4>トークナイズとid化</h4>\n\n\n\n<p>上の節では、単に「文章をトークン列として入力する」と書きましたが、そもそも深層学習ではあらゆる入力はベクトルとして扱わないといけません。文字列をベクトルとして扱う変換を省略していました。他の記事でもここはよく省略されています。</p>\n\n\n\n<p>文章の文字列を何らかのトークナイザで分割した上で、単語ごとにidを振る必要があります。<br>このトークナイズ処理とid割当はBERT本体のモデル構造とは別の話です。実際、Googleによる実装ではWordPieceというトークナイザを使っています。（これもGoogle製）</p>\n\n\n\n<p>英語とは別の言語の場合、必要であったり性能比較のために異なるトークナイザが使えます。<br>逆に言うと、このトークナイザが文章分割とid化を行うので、そのidを用いて事前学習したBERTのモデルは、後からトークナイザを変更することはできません。</p>\n\n\n\n<p>id化されたトークンは、one-hotベクトルとして入力した上で、一度行列変換をはさみ、その後にTransformer Encoderに入力されます。</p>\n\n\n\n<h4>positional embeddingとsegment embedding</h4>\n\n\n\n<p>もう一点、BERTへの入力に関しては面白い点があります。<br>それは、トークンのembeddingとは別に、２種類の情報を入力に組み込んでいるということです。<br>それは position embeddingとsegment embeddingです。</p>\n\n\n\n<p>もう一度、Transformer encoderの入力の図を貼ります。<br><a href=\"https://gyazo.com/547d078f0fb7b8140a7567fcd0eb1cb8\"></a></p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img src=\"https://i2.wp.com/i.gyazo.com/547d078f0fb7b8140a7567fcd0eb1cb8.png?w=1200&#038;ssl=1\" alt=\"\" data-recalc-dims=\"1\"/></figure>\n\n\n\n<p>モデル構造としては、transformer encoderは、すべての入力がトポロジー的に同一であり、順番を入れ替えても対称になっています。なのでこのまま学習をさせたとしても、トークンの順番が学習に考慮できません。</p>\n\n\n\n<figure class=\"wp-block-image\"><a href=\"https://gyazo.com/6497e4182582e1499f60d9ea9afef3b9\"><img src=\"https://i1.wp.com/i.gyazo.com/6497e4182582e1499f60d9ea9afef3b9.png?w=1200&#038;ssl=1\" alt=\"Image from Gyazo\" data-recalc-dims=\"1\"/></a></figure>\n\n\n\n<p>それを解決するために、そもそも入力自体に、位置番号を混ぜて学習をさせているのです。それがpositional encodingの意味です。<br><a href=\"https://gyazo.com/787ef5fca0f1618e489f2df90551c45b\"></a></p>\n\n\n\n<figure class=\"wp-block-image size-large\"><img src=\"https://i2.wp.com/i.gyazo.com/787ef5fca0f1618e489f2df90551c45b.png?w=1200&#038;ssl=1\" alt=\"\" data-recalc-dims=\"1\"/></figure>\n\n\n\n<p>厳密に言えば、位置を整数としてではなく、ベクトルで表現した上で、ベクトルとして足します。<br>回転行列を使って、いい感じに位置情報をモデルに理解させる工夫などを行っているようです。<br>詳細は元論文か、こちらの資料が参考になります。<a href=\"https://scrapbox.io/nishio/BERT%E3%81%A8Transformer\">BERTとTransformer &#8211; サイボウズラボ 機械学習勉強会</a></p>\n\n\n\n<p>さらに、同じように複数の文章を入れる際の、「文章を２つ入れたとき、このトークンはどっちの文章のもの？」という情報が、上記の入力の対称性で失われてしまいます。<br>これを、segment embeddingとして埋め込みます。</p>\n\n\n\n<p>以上で、トークンそれ自体とその他の情報２種類を足し合わせたものが、Transformer Encoderに入力されます。</p>\n\n\n\n<ul><li>トークン自体のembedding</li><li>文章のセグメントのembedding</li><li>トークン位置のembedding</li></ul>\n\n\n\n<figure class=\"wp-block-image size-large\"><img src=\"https://i0.wp.com/i.gyazo.com/da0c3a101a3089ac9a93399f81519e76.png?w=1200&#038;ssl=1\" alt=\"\" data-recalc-dims=\"1\"/></figure>\n\n\n\n<p>元論文より引用</p>\n\n\n\n<p>個人的には、この「構造をトークンに対して並列にするために失われた情報を、入力自体に埋め込んで解決」というところが非常に面白いと思います。</p>\n\n\n\n<p>ただし、ライブラリ等を使ってファインチューニングを行う場合は、ここらへんの入力について意識することは無いかもしれません。</p>\n\n\n\n<hr class=\"wp-block-separator\"/>\n\n\n\n<p>次回は学習データ、BERTの汎用性についてです。</p>\n","dateObject":"2020-06-12T12:00:00.000Z","date":"June 12, 2020","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"BERT","slug":"bert"},{"name":"NLP","slug":"nlp"},{"name":"機械学習","slug":"%e6%a9%9f%e6%a2%b0%e5%ad%a6%e7%bf%92"},{"name":"自然言語処理","slug":"%e8%87%aa%e7%84%b6%e8%a8%80%e8%aa%9e%e5%87%a6%e7%90%86"}],"author":{"name":"miyamonz","slug":"miyamoto"},"featured_media":null,"wordpress_id":1526}},"pageContext":{"id":"cc3686ef-da59-5a71-b9db-4499cf9f90e6","nextPath":"/2020/06/02/skyway-vs-twilio-video/","nextTitle":"SkyWay vs. Twilio Video","prevPath":"/2020/06/15/機械学習・自然言語処理のお勧め本など/","prevTitle":"機械学習・自然言語処理のお勧め本など"}}}