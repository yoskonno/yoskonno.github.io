{"componentChunkName":"component---src-templates-post-js","path":"/2018/12/28/rspecのletの遅延評価を利用してよりコンテクスチュア/","result":{"data":{"wordpressPost":{"id":"4d6b6521-e28a-5626-a097-07b0df451a41","title":"RSpecのletの遅延評価を利用してよりコンテクスチュアルなSpecを書く","excerpt":"<p>皆さんこんにちは。もう今年も残すところわずか3日となりました。早いものです。 さて、年末感のかけらもないネタですが、今回はRSpecのletについて、最近自分の中で1つの理解が得られた（気がする）ので書いてみようと思いま [&hellip;]</p>\n","slug":"rspec%e3%81%aelet%e3%81%ae%e9%81%85%e5%bb%b6%e8%a9%95%e4%be%a1%e3%82%92%e5%88%a9%e7%94%a8%e3%81%97%e3%81%a6%e3%82%88%e3%82%8a%e3%82%b3%e3%83%b3%e3%83%86%e3%82%af%e3%82%b9%e3%83%81%e3%83%a5%e3%82%a2","content":"<p class=\"part\" data-startline=\"3\" data-endline=\"4\">皆さんこんにちは。もう今年も残すところわずか3日となりました。早いものです。<br />\nさて、年末感のかけらもないネタですが、今回はRSpecのletについて、最近自分の中で1つの理解が得られた（気がする）ので書いてみようと思います。</p>\n<h2 id=\"これまでのletへの理解\" class=\"part\" data-startline=\"6\" data-endline=\"6\">これまでのletへの理解</h2>\n<p class=\"part\" data-startline=\"8\" data-endline=\"8\">ちょっと賢い単なる変数への束縛だと思っていました。</p>\n<p class=\"part\" data-startline=\"10\" data-endline=\"10\">公式ドキュメントであるRelishの<a href=\"https://relishapp.com/rspec/rspec-core/docs/helper-methods/let-and-let\" target=\"_blank\" rel=\"noopener\">Let and let!</a>によると、<code>let</code> は、</p>\n<pre class=\"part\" data-startline=\"12\" data-endline=\"26\"><code class=\"ruby hljs\">$count = <span class=\"hljs-number\">0</span>\nRSpec.describe <span class=\"hljs-string\">\"let\"</span> <span class=\"hljs-keyword\">do</span>\n  let(<span class=\"hljs-symbol\">:count</span>) { $count += <span class=\"hljs-number\">1</span> }\n\n  it <span class=\"hljs-string\">\"memoizes the value\"</span> <span class=\"hljs-keyword\">do</span>\n    expect(count).to eq(<span class=\"hljs-number\">1</span>)\n    expect(count).to eq(<span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-keyword\">end</span>\n\n  it <span class=\"hljs-string\">\"is not cached across examples\"</span> <span class=\"hljs-keyword\">do</span>\n    expect(count).to eq(<span class=\"hljs-number\">2</span>)\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p class=\"part\" data-startline=\"28\" data-endline=\"29\">同じexampleの中（👆で言うと “it” の中）では常に値が一緒である事が保証されるようです。<br />\nまた、 <code>let!</code> は、</p>\n<pre class=\"part\" data-startline=\"31\" data-endline=\"47\"><code class=\"ruby hljs\">$count = <span class=\"hljs-number\">0</span>\nRSpec.describe <span class=\"hljs-string\">\"let!\"</span> <span class=\"hljs-keyword\">do</span>\n  invocation_order = []\n\n  let!(<span class=\"hljs-symbol\">:count</span>) <span class=\"hljs-keyword\">do</span>\n    invocation_order &lt;&lt; <span class=\"hljs-symbol\">:let!</span>\n    $count += <span class=\"hljs-number\">1</span>\n  <span class=\"hljs-keyword\">end</span>\n\n  it <span class=\"hljs-string\">\"calls the helper method in a before hook\"</span> <span class=\"hljs-keyword\">do</span>\n    invocation_order &lt;&lt; <span class=\"hljs-symbol\">:example</span>\n    expect(invocation_order).to eq([<span class=\"hljs-symbol\">:let!</span>, <span class=\"hljs-symbol\">:example</span>])\n    expect(count).to eq(<span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p class=\"part\" data-startline=\"49\" data-endline=\"49\">exampleが実行される前に評価＆束縛されるようです。</p>\n<p class=\"part\" data-startline=\"51\" data-endline=\"51\">また、日本語Googleで「RSpec let」と検索すると、次のような記事がヒットします。</p>\n<ul class=\"part\" data-startline=\"53\" data-endline=\"56\">\n<li class=\"\" data-startline=\"53\" data-endline=\"53\"><a href=\"https://qiita.com/hirotakasasaki/items/fa3b131e27f5d0694c2c\" target=\"_blank\" rel=\"noopener\">RSpec の letとlet!とbeforeの挙動と実行される順番 &#8211; Qiita</a></li>\n<li class=\"\" data-startline=\"54\" data-endline=\"54\"><a href=\"https://qiita.com/jnchito/items/cdd9eef2ed193267c651\" target=\"_blank\" rel=\"noopener\">RSpecのletを使うのはどんなときか？（翻訳） &#8211; Qiita</a></li>\n<li class=\"\" data-startline=\"55\" data-endline=\"56\"><a href=\"http://www.betterspecs.org/jp/#let\" target=\"_blank\" rel=\"noopener\">letとlet!を使う (Better Specs { rspec guidelines with ruby })</a></li>\n</ul>\n<p class=\"part\" data-startline=\"57\" data-endline=\"57\">ご覧の通り、大抵の記事では <code>let</code> と <code>let!</code> の評価順の違いと、メリットとしては公式ドキュメント同様にexmaple内での値の一貫性と、記事によっては可読性や、typoに気づきやすい等が挙げられています。</p>\n<p class=\"part\" data-startline=\"59\" data-endline=\"59\">しかし、いずれも単に（以下のように）example内で変数を自前でバインドする事に比べて、大したメリットに感じません。</p>\n<pre class=\"part\" data-startline=\"61\" data-endline=\"77\"><code class=\"ruby hljs\">$count = <span class=\"hljs-number\">0</span>\nRSpec.describe <span class=\"hljs-string\">\"let\"</span> <span class=\"hljs-keyword\">do</span>\n  it <span class=\"hljs-string\">\"memoizes the value\"</span> <span class=\"hljs-keyword\">do</span>\n    count = $count += <span class=\"hljs-number\">1</span>\n  \n    expect(count).to eq(<span class=\"hljs-number\">1</span>)\n    expect(count).to eq(<span class=\"hljs-number\">1</span>)\n  <span class=\"hljs-keyword\">end</span>\n\n  it <span class=\"hljs-string\">\"is not cached across examples\"</span> <span class=\"hljs-keyword\">do</span>\n    count = $count += <span class=\"hljs-number\">1</span>\n  \n    expect(count).to eq(<span class=\"hljs-number\">2</span>)\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p class=\"part\" data-startline=\"79\" data-endline=\"79\">さらにはこんな記事まであります。</p>\n<ul class=\"part\" data-startline=\"81\" data-endline=\"82\">\n<li class=\"\" data-startline=\"81\" data-endline=\"82\"><a href=\"https://techracho.bpsinc.jp/hachi8833/2018_04_11/54697\" target=\"_blank\" rel=\"noopener\">Rails tips: RSpecの<code>let</code>ブロックや<code>before</code>ブロックは基本避けるべき（翻訳）</a></li>\n</ul>\n<p class=\"part\" data-startline=\"83\" data-endline=\"84\">👆ではパフォーマンスの問題や、他で挙げられていた可読性が逆に損なわれていると言われています。<br />\n確かに、単なる変数束縛との違いが分からない状態では、初めてRSpecのコードを見た時のカオス感の大きな要因の一つとも思えます（実際思ってました）</p>\n<h2 id=\"理解した事\" class=\"part\" data-startline=\"86\" data-endline=\"86\">理解した事</h2>\n<p class=\"part\" data-startline=\"88\" data-endline=\"88\">先程挙げた公式ドキュメントの中には、こんな言及もあります。</p>\n<blockquote class=\"part\" data-startline=\"90\" data-endline=\"90\"><p>Note that let is lazy-evaluated: it is not evaluated until the first time the method it defines is invoked.</p></blockquote>\n<p class=\"part\" data-startline=\"94\" data-endline=\"94\">なるほど、どうやら <code>let</code> は遅延評価されるようです。ここで、ある思いが頭をよぎりました。</p>\n<p class=\"part\" data-startline=\"96\" data-endline=\"96\"><em>「letはsubjectを使った時に効果を発揮するのでは・・・？」</em></p>\n<h2 id=\"試しに書いてみた\" class=\"part\" data-startline=\"98\" data-endline=\"98\">試しに書いてみた</h2>\n<p class=\"part\" data-startline=\"100\" data-endline=\"100\">テスト対象のクラスは、引数として与えられた同クラスのインスタンスの性別から異なった文言を使って挨拶を返す次のような物とします:</p>\n<pre class=\"part\" data-startline=\"102\" data-endline=\"121\"><code class=\"ruby hljs\"><span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">Person</span></span>\n  SEX_MALE = <span class=\"hljs-number\">1</span>\n  SEX_FEMALE = <span class=\"hljs-number\">2</span>\n\n  <span class=\"hljs-keyword\">attr_reader</span> <span class=\"hljs-symbol\">:name</span>, <span class=\"hljs-symbol\">:sex</span>\n\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">initialize</span><span class=\"hljs-params\">(name, sex)</span></span>\n    @name = name\n    @sex = sex\n  <span class=\"hljs-keyword\">end</span>\n\n  <span class=\"hljs-comment\"># <span class=\"hljs-doctag\">@param</span> [Person] to_be_greeted</span>\n  <span class=\"hljs-function\"><span class=\"hljs-keyword\">def</span> <span class=\"hljs-title\">greet</span><span class=\"hljs-params\">(to_be_greeted)</span></span>\n    title = to_be_greeted.sex == SEX_MALE ? <span class=\"hljs-string\">\"Mr.\"</span> : <span class=\"hljs-string\">\"Ms.\"</span>\n\n    <span class=\"hljs-string\">\"Hi, <span class=\"hljs-subst\">#{title}</span><span class=\"hljs-subst\">#{to_be_greeted.name}</span>, my name is <span class=\"hljs-subst\">#{@name}</span>. It's a pleasure to meet you.\"</span>\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p class=\"part\" data-startline=\"123\" data-endline=\"123\">これに対して、RSpecは次のような感じになりました:</p>\n<pre class=\"part\" data-startline=\"125\" data-endline=\"145\"><code class=\"ruby hljs\">RSpec.describe Person <span class=\"hljs-keyword\">do</span>\n  describe <span class=\"hljs-string\">\"#greet\"</span> <span class=\"hljs-keyword\">do</span>\n    let(<span class=\"hljs-symbol\">:person</span>) { Person.new(<span class=\"hljs-string\">\"Issei\"</span>, Person::SEX_MALE) }\n\n    subject { person.greet(to_be_greeted) }\n\n    context <span class=\"hljs-string\">\"with a male person\"</span> <span class=\"hljs-keyword\">do</span>\n      let(<span class=\"hljs-symbol\">:to_be_greeted</span>) { Person.new(<span class=\"hljs-string\">\"Taro\"</span>, Person::SEX_MALE) }\n\n      it { is_expected.to eq <span class=\"hljs-string\">\"Hi, Mr.Taro, my name is Issei. It's a pleasure to meet you.\"</span> }\n    <span class=\"hljs-keyword\">end</span>\n\n    context <span class=\"hljs-string\">\"with a female person\"</span> <span class=\"hljs-keyword\">do</span>\n      let(<span class=\"hljs-symbol\">:to_be_greeted</span>) { Person.new(<span class=\"hljs-string\">\"Hanako\"</span>, Person::SEX_FEMALE) }\n\n      it { is_expected.to eq <span class=\"hljs-string\">\"Hi, Ms.Hanako, my name is Issei. It's a pleasure to meet you.\"</span> }\n    <span class=\"hljs-keyword\">end</span>\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<p class=\"part\" data-startline=\"147\" data-endline=\"147\">主題である <code>person.greet</code> の呼び出しだけは先に宣言しておいて、example毎に、引数である <code>to_be_greeted</code> を別途用意しています。これは、 <code>let</code> が遅延評価であるから実現できています。</p>\n<p class=\"part\" data-startline=\"149\" data-endline=\"149\">もちろんメソッドの呼び出し自体を、各exampleの <code>it</code> の中で行っても良いのですが、このくらいシンプルな振る舞いの検証であれば、この書き方の方がDSLを使っている感があって（RSpecの意図としても）良いように思います。好みの問題かもしれませんが。</p>\n<p class=\"part\" data-startline=\"151\" data-endline=\"152\">因みに、スタブを使う場合も同様にできます。同じくPersonを例にすると:<br />\n<small>（同じクラスのインスタンスを引数に取るので、この場合本来スタブを使うまでも無いのですが）</small></p>\n<pre class=\"part\" data-startline=\"154\" data-endline=\"170\"><code class=\"ruby hljs\">RSpec.describe Person <span class=\"hljs-keyword\">do</span>\n  describe <span class=\"hljs-string\">\"#greet\"</span> <span class=\"hljs-keyword\">do</span>\n    let(<span class=\"hljs-symbol\">:person</span>) { Person.new(<span class=\"hljs-string\">\"Issei\"</span>, Person::SEX_MALE) }\n\n    subject { person.greet(to_be_greeted) }\n\n    context <span class=\"hljs-string\">\"with a male person\"</span> <span class=\"hljs-keyword\">do</span>\n      let(<span class=\"hljs-symbol\">:to_be_greeted</span>) { double(<span class=\"hljs-symbol\">:to_be_greeted</span>, <span class=\"hljs-symbol\">name:</span> <span class=\"hljs-string\">\"Taro\"</span>, <span class=\"hljs-symbol\">sex:</span> Person::SEX_MALE) }\n\n      it { is_expected.to eq <span class=\"hljs-string\">\"Hi, Mr.Taro, my name is Issei. It's a pleasure to meet you.\"</span> }\n    <span class=\"hljs-keyword\">end</span>\n    \n    <span class=\"hljs-comment\"># ...</span>\n  <span class=\"hljs-keyword\">end</span>\n<span class=\"hljs-keyword\">end</span>\n</code></pre>\n<h2 id=\"まとめ\" class=\"part\" data-startline=\"172\" data-endline=\"172\">まとめ</h2>\n<p class=\"part\" data-startline=\"174\" data-endline=\"174\">RSpecはDSLを使っていて読みやすいSpecを書けるのはいいのですが、書き方が多岐に渡りすぎていて統率が難しいのです。<br />\nですが、綺麗な書き方を発見すると楽しいので皆さんも色々探してみて下さい。</p>\n<p class=\"part\" data-startline=\"176\" data-endline=\"176\">それでは良いお年を🎅</p>\n","dateObject":"2018-12-28T09:10:06.000Z","date":"December 28, 2018","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"DSL","slug":"dsl"},{"name":"RSpec","slug":"rspec"},{"name":"Ruby","slug":"ruby"}],"author":{"name":"issei_m","slug":"issei"},"featured_media":null,"wordpress_id":461}},"pageContext":{"id":"4d6b6521-e28a-5626-a097-07b0df451a41","nextPath":"/2018/12/07/phpのコレクションライブラリ-knapsack-を使ってみる/","nextTitle":"PHPのコレクションライブラリ Knapsack を使ってみる","prevPath":"/2019/01/09/upload-splatoon2-battle-histories-regularly-on-lambda/","prevTitle":"AWS Lambdaを使ってスプラトゥーン2の戦績をstat.inkに定期保存できるようにした"}}}