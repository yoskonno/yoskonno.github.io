{"componentChunkName":"component---src-templates-post-js","path":"/2018/12/07/phpのコレクションライブラリ-knapsack-を使ってみる/","result":{"data":{"wordpressPost":{"id":"ee871b3f-1343-5d0a-af23-804053afba64","title":"PHPのコレクションライブラリ Knapsack を使ってみる","excerpt":"<p>今日は僕が普段中規模以上のPJで使っている、PHPのコレクションライブラリ Knapsack の紹介をします。 特徴 Knapsackの主な特徴は、 コレクション操作用の高階関数が豊富 イミュータブル 全てが遅延評価 i [&hellip;]</p>\n","slug":"php%e3%81%ae%e3%82%b3%e3%83%ac%e3%82%af%e3%82%b7%e3%83%a7%e3%83%b3%e3%83%a9%e3%82%a4%e3%83%96%e3%83%a9%e3%83%aa-knapsack-%e3%82%92%e4%bd%bf%e3%81%a3%e3%81%a6%e3%81%bf%e3%82%8b","content":"<p class=\"part\" data-startline=\"3\" data-endline=\"3\">今日は僕が普段中規模以上のPJで使っている、PHPのコレクションライブラリ <a href=\"https://github.com/DusanKasan/Knapsack\" target=\"_blank\" rel=\"noopener\">Knapsack</a> の紹介をします。</p>\n<h2 id=\"特徴\" class=\"part\" data-startline=\"5\" data-endline=\"5\">特徴</h2>\n<p class=\"part\" data-startline=\"7\" data-endline=\"7\">Knapsackの主な特徴は、</p>\n<ul class=\"part\" data-startline=\"9\" data-endline=\"13\">\n<li class=\"\" data-startline=\"9\" data-endline=\"9\">コレクション操作用の高階関数が豊富</li>\n<li class=\"\" data-startline=\"10\" data-endline=\"10\">イミュータブル</li>\n<li class=\"\" data-startline=\"11\" data-endline=\"11\">全てが遅延評価</li>\n<li class=\"\" data-startline=\"12\" data-endline=\"13\">iterable、またはこれを返すcallableは全て受け入れ可能</li>\n</ul>\n<p class=\"part\" data-startline=\"14\" data-endline=\"15\">の2点だと思います。<br />\n他にも些細な事ですが、主要な機能を提供するメソッドは全てTraitで提供されていて、更に実装の実態自体は関数として提供されているので、使いたい機能だけを切り出して自分のクラスやロジックに組み込める点と言った点が面白いです。</p>\n<p class=\"part\" data-startline=\"17\" data-endline=\"17\">さて、上記に挙げた4つの特徴について、昨今の開発シーンにおいては今更特筆すべき事ではないかもしれませんが、1つ1つ紹介していきたいと思います。</p>\n<h2 id=\"コレクション操作用の高階関数が豊富\" class=\"part\" data-startline=\"19\" data-endline=\"19\">コレクション操作用の高階関数が豊富</h2>\n<p class=\"part\" data-startline=\"21\" data-endline=\"22\">Knapsackのコレクションは、通常であれば <code>\\DusanKasan\\Knapsack\\Collection</code> クラスを使います。<br />\n以下のようにコンストラクタか、<code>::from()</code> メソッドにソースとなるiterable（かiterableを返すcallable）な値を入れる事で使用が可能です。</p>\n<pre class=\"part\" data-startline=\"24\" data-endline=\"30\"><code class=\"php hljs\">$collectionA = <span class=\"hljs-keyword\">new</span> DusanKasan\\Knapsack\\Collection(range(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>));\n$collectionB = DusanKasan\\Knapsack\\Collection::from(range(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>)); <span class=\"hljs-comment\">// 同じ</span>\n\n<span class=\"hljs-comment\">// 実は range と言うヘルパーメソッドも存在する</span>\n$collectionC = DusanKasan\\Knapsack\\Collection::range(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>); <span class=\"hljs-comment\">// これも👆2つと同じ</span>\n</code></pre>\n<p class=\"part\" data-startline=\"32\" data-endline=\"33\">コレクションを初期化した後は、<code>map()</code> や <code>filter()</code> などの高階関数（メソッド）を使ってコレクションの要素に対して関数を適用する事ができます。<br />\nこれらのメソッドは関数を適用後のコレクションを返すので、メソッドチェーンが可能となります。</p>\n<pre class=\"part\" data-startline=\"35\" data-endline=\"45\"><code class=\"php hljs\">$collection = DusanKasan\\Knapsack\\Collection::range(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>);\n\n<span class=\"hljs-comment\">// 0,4,10,24,40,64,90,C4,100,144,190,1E4,240,2A4,310,384,400,484,510,5A4,640,6E4,790,844,900,9C4,A90,B64,C40,D24,E10,F04,1000,1104,1210,1324,1440,1564,1690,17C4,1900,1A44,1B90,1CE4,1E40,1FA4,2110,2284,2400,2584,2710</span>\n<span class=\"hljs-keyword\">echo</span> $collection\n    -&gt;map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">($v)</span> </span>{ <span class=\"hljs-keyword\">return</span> pow($v, <span class=\"hljs-number\">2</span>); }) <span class=\"hljs-comment\">// 値を2乗</span>\n    -&gt;filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">($v)</span> </span>{ <span class=\"hljs-keyword\">return</span> $v % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>; }) <span class=\"hljs-comment\">// 奇数を除外</span>\n    -&gt;map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">($v)</span> </span>{ <span class=\"hljs-keyword\">return</span> dechex($v); }) <span class=\"hljs-comment\">// 数値を16進数に</span>\n    -&gt;map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(string $v)</span> </span>{ <span class=\"hljs-keyword\">return</span> strtoupper($v); }) <span class=\"hljs-comment\">// 英字を大文字に</span>\n    -&gt;reduce(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">($acc, string $v)</span> </span>{ <span class=\"hljs-keyword\">return</span> $acc . ($acc === <span class=\"hljs-string\">''</span> ? <span class=\"hljs-string\">''</span> : <span class=\"hljs-string\">','</span>) . $v; }, <span class=\"hljs-string\">''</span>); <span class=\"hljs-comment\">// ,区切りで連結</span>\n</code></pre>\n<p class=\"part\" data-startline=\"47\" data-endline=\"47\">配列に地道に <code>array_map</code>, <code>array_filter</code> をネストしていくより可読性が高いですね。</p>\n<p class=\"part\" data-startline=\"49\" data-endline=\"49\">メソッドチェーンについては大抵のコレクションライブラリ（例えばdoctrine/collectionsとか）にも備わっている機能なので特段珍しくはないですが、Knapsackは高階関数メソッドを豊富に備えています。</p>\n<p class=\"part\" data-startline=\"51\" data-endline=\"52\"><a href=\"http://dusankasan.github.io/Knapsack/\" target=\"_blank\" rel=\"noopener\">公式ドキュメント</a>に全てのメソッドが書かれていますが、上で使った <code>map()</code>, <code>filter()</code>, <code>reduce()</code> はもちろん、 <code>zip()</code>, <code>groupBy()</code>, <code>flattern()</code> 等が全部で86種類もあります。<br />\nScalaのコレクションライブラリ並に多機能ですね。</p>\n<p class=\"part\" data-startline=\"54\" data-endline=\"54\">また、<code>reduce()</code> 等の畳込み処理系以外は関数を適用後のコレクションを返すので、全てメソッドチェーンが可能となっています。</p>\n<h2 id=\"イミュータブル\" class=\"part\" data-startline=\"56\" data-endline=\"56\">イミュータブル</h2>\n<p class=\"part\" data-startline=\"58\" data-endline=\"59\">Knapsackのコレクションはイミュータブルです。先程、コレクションに存在する多数の高階関数はほぼメソッドチェーンが可能と紹介しましたが、実はこれらは全てイミュータブルとなっています。<br />\nコレクションはインスタンス自身が保持している値に関数を適用する代わりに、関数を適用した値により新しくコレクションを生成し、返します。</p>\n<pre class=\"part\" data-startline=\"61\" data-endline=\"69\"><code class=\"php hljs\">$collection = DusanKasan\\Knapsack\\Collection::range(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>);\n$squared = $collection-&gt;map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">($v)</span> </span>{ <span class=\"hljs-keyword\">return</span> pow($v, <span class=\"hljs-number\">2</span>); }); <span class=\"hljs-comment\">// 値を2乗</span>\n$onlyEven = $squared-&gt;filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">($v)</span> </span>{ <span class=\"hljs-keyword\">return</span> $v % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>; }); <span class=\"hljs-comment\">// 奇数を除外</span>\n$hexed = $onlyEven-&gt;map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">($v)</span> </span>{ <span class=\"hljs-keyword\">return</span> dechex($v); }); <span class=\"hljs-comment\">// 数値を16進数に</span>\n\n<span class=\"hljs-comment\">// 100, 10000, 10000, \"2710\"</span>\nvar_dump($collection-&gt;last(), $squared-&gt;last(), $onlyEven-&gt;last(), $hexed-&gt;last());\n</code></pre>\n<p class=\"part\" data-startline=\"71\" data-endline=\"72\">このように都度結果を別の変数にバインドしてみると、1つ前のコレクションの値が計算の影響を受けていない事が分かります。<br />\nこれにより、どのような関数の引数にも安心してコレクションを渡す事ができます。</p>\n<h2 id=\"全てが遅延評価\" class=\"part\" data-startline=\"74\" data-endline=\"74\">全てが遅延評価</h2>\n<p class=\"part\" data-startline=\"76\" data-endline=\"77\">Knapsackのコレクションは適用した関数は全てイテレーション時まで遅延します。<br />\n例えば、最初の例から最後の畳み込みである <code>reduce()</code> を省略してみます。</p>\n<pre class=\"part\" data-startline=\"79\" data-endline=\"87\"><code class=\"php hljs\">$collection = DusanKasan\\Knapsack\\Collection::range(<span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">100</span>);\n$collection\n    -&gt;map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">($v)</span> </span>{ <span class=\"hljs-keyword\">return</span> pow($v, <span class=\"hljs-number\">2</span>); }) <span class=\"hljs-comment\">// 値を2乗</span>\n    -&gt;filter(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">($v)</span> </span>{ <span class=\"hljs-keyword\">return</span> $v % <span class=\"hljs-number\">2</span> === <span class=\"hljs-number\">0</span>; }) <span class=\"hljs-comment\">// 奇数を除外</span>\n    -&gt;map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">($v)</span> </span>{ <span class=\"hljs-keyword\">return</span> dechex($v); }) <span class=\"hljs-comment\">// 数値を16進数に</span>\n    -&gt;map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(string $v)</span> </span>{ <span class=\"hljs-keyword\">return</span> strtoupper($v); }); <span class=\"hljs-comment\">// 英字を大文字に</span>\n; \n</code></pre>\n<p class=\"part\" data-startline=\"89\" data-endline=\"89\">この時点では、3つの <code>map()</code> と 1つの <code>filter()</code> の計算はまだされません。それどころか、最初の <code>range()</code> による生成処理自体も遅延されるのでこの時点では本当に何も実行されていません。</p>\n<p class=\"part\" data-startline=\"91\" data-endline=\"92\">畳み込みである <code>reduce()</code> や、foreach によるイテレーション、あるいは <code>toArray()</code> による配列への変換を行った時に一気に処理が行われます。<br />\nつまり、以下の記述は全く一緒である事になります:</p>\n<pre class=\"part\" data-startline=\"94\" data-endline=\"104\"><code class=\"php hljs\"><span class=\"hljs-keyword\">foreach</span> ($collection-&gt;map($funcA)-&gt;map($funcB)-&gt;filter($funcC)-&gt;map($funcD) <span class=\"hljs-keyword\">as</span> $v) {\n    <span class=\"hljs-keyword\">echo</span> $v;\n}\n\n<span class=\"hljs-keyword\">foreach</span> ($collection <span class=\"hljs-keyword\">as</span> $v) {\n    <span class=\"hljs-keyword\">if</span> ($funcC($tmp = $funcB($funcA($v)))) {\n        <span class=\"hljs-keyword\">echo</span> $funcD($tmp);\n    }\n}\n</code></pre>\n<h2 id=\"iterable、またはこれを返すcallableは全て受け入れ可能\" class=\"part\" data-startline=\"106\" data-endline=\"106\">iterable、またはこれを返すcallableは全て受け入れ可能</h2>\n<p class=\"part\" data-startline=\"108\" data-endline=\"110\">実は、これが僕が一番Knapsackの気に入ってる点です。<br />\n一番最初にコレクションの初期化方法として、Collectionクラスのコンストラクタと <code>::from()</code> を挙げましたが、これらには表題の通りiterableか、iterableを返すcallableなら何でも渡す事が可能です。<br />\nGeneratorも当然渡す事が可能ですし、先程の遅延処理も相まってDoctrine ORMのような、1エンティティのメモリコストが非常に大きい物を扱うのに適しています。</p>\n<p class=\"part\" data-startline=\"112\" data-endline=\"112\">例えば、以下は全ユーザーのIDと名前、またそのユーザーのコメント数を集計した物をCSVの行として表した物を取得します。</p>\n<pre class=\"part\" data-startline=\"114\" data-endline=\"164\"><code class=\"php hljs\"><span class=\"hljs-comment\">/** <span class=\"hljs-doctag\">@var</span> Acme\\User[] $users */</span>\n$users = DusanKasan\\Knapsack\\Collection::from(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">()</span> <span class=\"hljs-title\">use</span> <span class=\"hljs-params\">($em)</span> </span>{\n    $usersQuery = $em-&gt;createQuery(<span class=\"hljs-string\">'SELECT u FROM Acme\\User u'</span>);\n    \n    <span class=\"hljs-keyword\">foreach</span> ($usersQuery-&gt;iterate() <span class=\"hljs-keyword\">as</span> $counter =&gt; [$user]) { <span class=\"hljs-comment\">// 渡ってくる値はarrayでラップされているのでアンラップする必要がある</span>\n        assert($user <span class=\"hljs-keyword\">instanceof</span> Acme\\User);\n    \n        <span class=\"hljs-keyword\">yield</span> $user;\n    \n        <span class=\"hljs-keyword\">if</span> (($counter + <span class=\"hljs-number\">1</span>) % <span class=\"hljs-number\">1000</span> === <span class=\"hljs-number\">0</span>) {\n            $em-&gt;clear(); <span class=\"hljs-comment\">// 1000回トラバースする毎にEntityManagerのオブジェクトを開放する</span>\n        }\n    }\n});\n\n<span class=\"hljs-comment\">// [ [1, \"Ariana Grande\", 10], [2, \"Taylor Swift\", 125], ...]</span>\n$csvRows = $users\n    <span class=\"hljs-comment\">// 1000ユーザー毎のチャンクにする。コレクションはは次のような物になる</span>\n    <span class=\"hljs-comment\">// [ [$u1, $u2, ..., $u1000], [$u1001, $u1002, ..., ], ...]</span>\n    -&gt;partition(<span class=\"hljs-number\">1000</span>) \n    -&gt;map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">(iterable $chunkedUsers)</span> </span>{\n        <span class=\"hljs-comment\">// 1000ユーザー分のidの配列を得る</span>\n        $userIds = DusanKasan\\Knapsack\\Collection::from($chunkedUsers)-&gt;map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">($u)</span> </span>{ <span class=\"hljs-keyword\">return</span> $u-&gt;getId(); })-&gt;toArray();\n\n        <span class=\"hljs-comment\">// idの配列から、ユーザー毎のコメント数をSQLで集計し、idの配列順で返す物を想定</span>\n        $userNumComments = getUserNumCommentsFor($userIds);\n\n        <span class=\"hljs-comment\">// ユーザーと当該ユーザーの書き込み数をzipする。コレクションは次のような物になる</span>\n        <span class=\"hljs-comment\">// [ [$u1, $u1Comments], [$u2, $u2Comments], ..., [$u1000, $u1000Comments] ]</span>\n        <span class=\"hljs-keyword\">return</span> DusanKasan\\Knapsack\\Collection::from($chunkedUsers)\n            -&gt;zip($userNumComments);\n    })\n    <span class=\"hljs-comment\">// 1000件毎のチャンクを平坦化する。コレクションは次のように変化する</span>\n    <span class=\"hljs-comment\">// before: [ [ [$u1, $u1Comments], [$u2, $u2Comments], ..., [$u1000, $u1000Comments] ], [ [$u1001, $u1001Comments, ...] ], ...]</span>\n    <span class=\"hljs-comment\">// after:  [ [$u1, $u1Comments], [$u2, $u2Comments], ..., [$uN, $uNComments]]</span>\n    -&gt;flatten(<span class=\"hljs-number\">1</span>)\n    -&gt;map(<span class=\"hljs-function\"><span class=\"hljs-keyword\">function</span> <span class=\"hljs-params\">($zipped)</span> </span>{\n        <span class=\"hljs-comment\">// $zippedは [$uN, $uComments] となっている</span>\n    \n        $zippedCollection = \\DusanKasan\\Knapsack\\Collection::from($zipped);\n        $user = $zippedCollection-&gt;first();\n        $numComments = $zippedCollection-&gt;last();\n        assert($user <span class=\"hljs-keyword\">instanceof</span> Acme\\User);\n\n        <span class=\"hljs-keyword\">return</span> [$user-&gt;getId(), $user-&gt;getName(), $numComments];\n    })\n    -&gt;values()\n    -&gt;toArray()\n;\n</code></pre>\n<p class=\"part\" data-startline=\"166\" data-endline=\"166\">上記では、全体のユーザー数が何人であれ一度にメモリに乗るUserオブジェクトは最大で1000個までなので、メモリを節約する事が可能となっています。</p>\n<h2 id=\"注意点\" class=\"part\" data-startline=\"168\" data-endline=\"168\">注意点</h2>\n<p class=\"part\" data-startline=\"170\" data-endline=\"172\">PHPは7から配列がかなり高速化されたので、ジェネレータをふんだんに使うKnapsackコレクションは標準の配列処理に比べ、かなりパフォーマンスの面では劣ります。<br />\nWebサーバーがHTTPレスポンスを作るのに扱うデータ量ぐらいであれば気にならないですが、バッチサーバー等で大規模なデータを処理する際は注意が必要な場面があります。<br />\nしかし、配列に落とし込むには相応のメモリが必要なので、パフォーマンスとのトレードオフとなります。</p>\n","dateObject":"2018-12-07T08:51:31.000Z","date":"December 07, 2018","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"Collection","slug":"collection"},{"name":"PHP","slug":"php"}],"author":{"name":"issei_m","slug":"issei"},"featured_media":{"media_details":{"sizes":{"large":{"source_url":"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2018/12/cynthia-del-rio-88326-unsplash-e1544172634915.jpg?fit=1024%2C683&ssl=1","height":683,"width":1024},"medium_large":{"source_url":"https://i2.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2018/12/cynthia-del-rio-88326-unsplash-e1544172634915.jpg?fit=768%2C512&ssl=1","height":512,"width":768}}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2018/12/cynthia-del-rio-88326-unsplash-e1544172634915.jpg"},"wordpress_id":439}},"pageContext":{"id":"ee871b3f-1343-5d0a-af23-804053afba64","nextPath":"/2018/11/15/s3のgetリクエストでrangeヘッダーを使う/","nextTitle":"S3のGETリクエストでRangeヘッダーを使う","prevPath":"/2018/12/28/rspecのletの遅延評価を利用してよりコンテクスチュア/","prevTitle":"RSpecのletの遅延評価を利用してよりコンテクスチュアルなSpecを書く"}}}