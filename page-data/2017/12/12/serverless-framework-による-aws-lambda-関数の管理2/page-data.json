{"componentChunkName":"component---src-templates-post-js","path":"/2017/12/12/serverless-framework-による-aws-lambda-関数の管理2/","result":{"data":{"wordpressPost":{"id":"18286794-1fc4-5174-873e-7fc9afe995a6","title":"Serverless Framework による AWS Lambda 関数の管理2","excerpt":"<p>今回のトピック 前回の投稿で、Serverless Framework （以下、Serverless）を使って AWS Lambda 関数、およびそれのトリガーとなるイベントの定義まで出来たと思います。 今回は、前回紹介 [&hellip;]</p>\n","slug":"serverless-framework-%e3%81%ab%e3%82%88%e3%82%8b-aws-lambda-%e9%96%a2%e6%95%b0%e3%81%ae%e7%ae%a1%e7%90%862","content":"<h1>今回のトピック</h1>\n<p><a href=\"https://stg-engineering-wp.mobalab.net/2017/11/18/serverless-framework-%e3%81%ab%e3%82%88%e3%82%8b-aws-lambda-%e9%96%a2%e6%95%b0%e3%81%ae%e7%ae%a1%e7%90%861/\">前回の投稿</a>で、Serverless Framework （以下、Serverless）を使って AWS Lambda 関数、およびそれのトリガーとなるイベントの定義まで出来たと思います。</p>\n<p>今回は、前回紹介できなかった以下の細かいトピックについて記載していきます。</p>\n<ul>\n<li>serverless.yml での変数の扱い</li>\n<li>外部ファイル</li>\n<li>stage について</li>\n<li>serverless-external-s3-event プラグイン</li>\n<li>その他、tips 等</li>\n</ul>\n<p><!--more--></p>\n<h1>serverless.yml での変数の扱い</h1>\n<p>serverless.yml ファイルでは、変数をうまく使うことで、簡潔な記述、柔軟な運用などが可能になります。</p>\n<p>詳しくは<a href=\"https://serverless.com/framework/docs/providers/aws/guide/variables/\" target=\"_blank\" rel=\"noopener\">ドキュメント</a>を参照していただくとして、ここではドキュメントでは分かりづらい点、記載がない点について説明していきます。</p>\n<h2>変数の種類</h2>\n<p>serverless.yml の中で使える変数にはいくつかの種類があります。それぞれ見ていきます。</p>\n<h3>serverless.yml 自身で定義されているもの</h3>\n<p>serverless.yml 内で何度も使うような値は、変数として定義することにより、その後の修正が容易になります。具体的にはファイル内の <code>custom</code> キーの配下に値を定義します。</p>\n<pre><code>custom:\n  bucket:\n    module1: mycompany-module1\n    module2: mycompany-module2\n</code></pre>\n<p>定義した値を使うには、<code>self</code> キーワードを使い、以下のようにします。</p>\n<pre><code>${self:custom.bucket.module1}\n</code></pre>\n<h3>環境変数</h3>\n<p><code>sls</code> (or <code>serverless</code>) コマンドを実行しているシェルの環境変数を、以下の通り参照することが出来ます。</p>\n<pre><code>${env:SOME_ENV}\n</code></pre>\n<h3>コマンドライン引数</h3>\n<p><code>sls</code> コマンドに対するコマンドライン引数を参照することも可能です。主な用途としては、後述するステージの切り替え（本番、開発、ステージング等）でしょうか。</p>\n<p>渡すことの出来る引数は、以下のページに記載があります（AWS の場合）。</p>\n<p><a href=\"https://serverless.com/framework/docs/providers/aws/cli-reference/deploy/\">Serverless Framework Commands &#8211; AWS Lambda &#8211; Deploy</a></p>\n<p>参照方法は、例えば stage 引数であれば以下の通りです。</p>\n<pre><code>${opt:stage}\n</code></pre>\n<h2>変数が未定義の場合のデフォルト値</h2>\n<p>変数が定義されていない場合、デフォルト値を使用したい場合も多いと思います。その場合は、以下のようにします（ドキュメントより引用・改変）。</p>\n<pre><code>custom:\n  myRegion: ${opt:region, 'us-west-1'}\n</code></pre>\n<h1>外部ファイル</h1>\n<h2>外部ファイルの読み込み方</h2>\n<p>serverless.yml からは、外部の YAML ファイルなどを読み込むことが出来ます。serverless.yml 内部の複数箇所で同じような内容を定義したい場合は、その定義内容を外部の YAML ファイルにしておき、それを serverless.yml の複数箇所で参照することが出来ます。</p>\n<p>以下のような外部 YAML ファイルを考えます。</p>\n<pre><code>foo:\n  - foo1\n  - foo2\nbar: something\n</code></pre>\n<p>参照方法としては、いくつかのパターンがありますので、以下に記載します。</p>\n<pre><code># 外部ファイルを全て参照する場合\n${file(./external_file.yml)}\n# 外部ファイルの一部を参照する場合\n${file(./external_file.yml):foo}\n</code></pre>\n<h2>外部ファイルと変数</h2>\n<p>外部ファイルでも、通常の serverless.yml と同じように変数を参照することが出来ます。ただし、読み込み元のファイルで定義された変数を参照することは出来ないようです。</p>\n<p>以下のようなファイルがあったとします。</p>\n<pre><code># serverless.yml\ncustom:\n  foo_in_parent: something\nfunctions:\n  handler: handler.foo\n  name: foo_func\n  events: ${file(./events.yml)}\n</code></pre>\n<p>そこで読み込まれる events.yml では、serverless.yml で定義した値は読み込めないようです。</p>\n<pre><code># events.yml\n- cloudwatchEvent:\n    event:\n      source: ${self:custom.foo_in_parent} # ダメ\n</code></pre>\n<h1>ステージ</h1>\n<p>Serverless では、本番、ステージングなど、異なる環境を使い分ける事が出来ます。が、そのためには事前にある程度設計を行っておく必要があります。</p>\n<h2>ドキュメント推奨の方法</h2>\n<p><a href=\"https://serverless.com/framework/docs/providers/aws/guide/workflow/\">公式ドキュメント</a> では、以下のように記載してあります。</p>\n<ul>\n<li>At the very least, use a dev and production stage.</li>\n<li>Use different AWS accounts for stages.</li>\n<li>In larger teams, each member should use a separate AWS account and their own stage for development.</li>\n</ul>\n<p>1番に関しては異論がないのですが、2番は場合によっては問題かもしれません。</p>\n<p>推奨の方法では、dev と production で違う AWS アカウントを用意して、それぞれのアカウント内部で同じ名前の Lambda 関数などを定義するのですが、小さいプロジェクトとかだと、dev と production で異なるアカウントを使い分けるという事をしていない場合も多いと思います。その場合の方法は後述します。</p>\n<p>さて、アカウントを使い分ける場合は、それほど難しい事は無いと思います。ステージ名と同じプロファイルを用意しておけば、以下のようにすれば良いですし、</p>\n<pre><code>provider:\n  stage: ${opt:stage, 'dev'}\n  profile: ${self:provider.stage}\n</code></pre>\n<p>ステージ名とプロファイル名が異なる場合は、以下のようにします。</p>\n<pre><code>custom:\n  profiles:\n    dev: awsProfileForDev\n    production: awsProfileForProduction\nprovider:\n  stage: ${opt:stage, 'dev'}\n  profile: ${self:custom.profiles.${self:provider.stage}}\n</code></pre>\n<h2>1つのアカウントを使う場合</h2>\n<p>非推奨のようですが、1つの AWS アカウントを本番と開発の両方で使う場合は、少し工夫が必要です。</p>\n<pre><code># serverless.yml\n# 開発と本番で毎に使い分ける必要があるリソースは、custom に定義しておく\ncustom:\n  bucket:\n    dev: example-bucket-dev\n    pro: example-bucket\n\nprovider:\n  # Serverless で作成される CloudFormation スタックなどには stage 名が含まれるので、\n  # 開発でも本番でもないと分かるような適当な名前（default や common など）を設定しておく。\n  stage: 'default'\n\nfunctions:\n  # 関数名に dev_ プリフィックスをつける。\n  # 他に方法が無いか、については後述する。\n  dev_foo_func:\n    handler: handler.dev_foo_func\n    name: dev_foo_func\n    events:\n      # existingS3 に関しては後述\n      - existingS3:\n          bucket: ${self:custom.bucket.dev}\n          # 開発、本番で共通の部分は外部ファイルで共通化しておく。\n          # s3_event_foo.yml の内容は省略します。\n          events: ${file(./yaml/s3_event_foo.yml):events}\n          rules: ${file(./yaml/s3_event_foo.yml):rules}\n  pro_foo_func:\n    handler: handler.pro_foo_func\n    name: dev_foo_func\n    events:\n      - existingS3:\n          bucket: ${self:custom.bucket.pro}\n          events: ${file(./yaml/s3_event_foo.yml):events}\n          rules: ${file(./yaml/s3_event_foo.yml):rules}\n</code></pre>\n<p>handler.py では、以下のようにします。他の言語の場合は、適宜読み替えてください。</p>\n<pre><code>def dev_foo_func(event, context):\n  foo_func('dev', event, context)\n\ndef pro_foo_func(event, context):\n  foo_func('pro', event, context)\n\ndef foo_func(stage, event, context):\n  # いろいろな処理\n</code></pre>\n<p>関数名に dev_, pro_ のようなプリフィックスをつけて複数定義するのはイマイチなので、以下のように出来ないか、という意見もあると思います。</p>\n<pre><code># うまくいかない\nfunctions:\n  # 関数は1つだけ定義\n  foo_func:\n    # 実体は stage オプションをつけて実行する事で、複数定義\n    handler: handler.${self:provider.stage}_foo_func\n    name: ${self:provider.stage}_foo_func\n    events:\n      # 省略\n</code></pre>\n<p>結論から言うと、この方法ではうまくいきませんでした。関数定義の <code>name</code> （この場合は <code>dev_foo_func</code> あるいは <code>pro_foo_func</code> ）は、関数定義のエントリーのキー（ここでは <code>foo_func</code>）と同一でなある事が前提のプラグインがいくつか存在するからです（この後説明する serverless-external-s3-event もその1つ）</p>\n<h1>serverless-external-s3-event プラグイン</h1>\n<h2>既存の S3 バケットを使用できるようにする</h2>\n<p>現在の Serverless の仕様だと、<code>events</code> に S3 を指定すると、指定された名前のバケットが作成され、既に同名のバケットが存在する場合はエラーになります。（詳細は以下のドキュメントを参照。）</p>\n<p><a href=\"https://serverless.com/framework/docs/providers/aws/events/s3/\">Serverless Framework &#8211; AWS Lambda Events &#8211; S3</a></p>\n<p>インフラが全て自分（や自部署）の手の届く範囲にあるのでしたら問題ないかもしれませんが、実際問題として、既存の S3 バケットやそれを使っているシステムがあり、それに対して新規で Lambda 関数のイベントを設定するというのもよくあるユースケースかと思います。そうしたときに、現在の Serverless では対応出来ません。実際に、以下のような issue が立っています。</p>\n<ul>\n<li><a href=\"https://github.com/serverless/serverless/issues/2154\">Can&#8217;t subscribe to events of existing S3 bucket · Issue #2154 · serverless/serverless</a></li>\n<li><a href=\"https://github.com/serverless/serverless/issues/4241\">Introduce a functionality which attach events to an existing resource · Issue #4241 · serverless/serverless</a></li>\n</ul>\n<p>1つめの issue のコメントで紹介されていますが、この問題に対応するためのプラグインが <a href=\"https://github.com/matt-filion/serverless-external-s3-event\">serverless-external-s3-event</a> です。</p>\n<h2>インストール、設定</h2>\n<p>インストールは npm を使います。以下の（ドキュメントに書かれている）通り -g はつけずに、package.json をコミットした方が良いと思います。</p>\n<pre><code>npm install serverless-external-s3-event\n</code></pre>\n<p>serverless.yml の設定は以下のように行います。</p>\n<pre><code>    events:\n      - existingS3:\n          bucket: a-bucket-that-already-exists\n          events:\n            - s3:ObjectCreated:*\n          rules:\n             - prefix: path/to/some/dir/\n             - suffix: .csv\n</code></pre>\n<p>詳細はドキュメントを参照してください。</p>\n<h1>まとめ</h1>\n<p>今回は、<a href=\"https://stg-engineering-wp.mobalab.net/2017/11/18/serverless-framework-%e3%81%ab%e3%82%88%e3%82%8b-aws-lambda-%e9%96%a2%e6%95%b0%e3%81%ae%e7%ae%a1%e7%90%861/\">前回の投稿</a>で紹介できなかった機能などについて説明しました。</p>\n<p>長くなったのでこの辺で終わりますが、他にも何か tips などを思い出したら、別エントリーとしてまとめようと思います。</p>\n","dateObject":"2017-12-12T08:38:04.000Z","date":"December 12, 2017","categories":[{"name":"Uncategorized","slug":"uncategorized"}],"tags":[{"name":"Lambda","slug":"lambda"},{"name":"Serverless","slug":"serverless"}],"author":{"name":"中の人（管理者）","slug":"engineering_8qmk0b"},"featured_media":{"media_details":{"sizes":{"large":{"source_url":"https://i1.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2017/11/serverless-framework-e1515487705166.png?fit=1024%2C441&ssl=1","height":441,"width":1024},"medium_large":{"source_url":"https://i1.wp.com/stg-engineering-wp.mobalab.net/wp-content/uploads/2017/11/serverless-framework-e1515487705166.png?fit=768%2C331&ssl=1","height":331,"width":768}}},"source_url":"https://stg-engineering-wp.mobalab.net/wp-content/uploads/2017/11/serverless-framework-e1515487705166.png"},"wordpress_id":40}},"pageContext":{"id":"18286794-1fc4-5174-873e-7fc9afe995a6","nextPath":"/2017/11/18/serverless-framework-による-aws-lambda-関数の管理1/","nextTitle":"Serverless Framework による AWS Lambda 関数の管理1","prevPath":"/2018/01/10/terraform-によるインフラ構築/","prevTitle":"Terraform によるインフラ構築"}}}